{"./":{"url":"./","title":"本书简介","keywords":"","body":"本书简介 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1010.html":{"url":"books/1010.html","title":"数据库简介","keywords":"","body":"数据库简介 数据库技术是研究数据库的结构、存储、设计、管理和应用的一门软件学科。 数据库系统本质上是一个用计算机存储信息的系统。数据库管理系统是位于用户与操作系统之间的一层数据管理软件,其基本目标是提供一个可以方便、有效地存取数据库信息的环境。数据库就是信息的集合,它是收集计算机数据的仓库或容器,系统用户可以对这些数据执行一系列操作。设计数据库系统的目的是为了管理大量信息,给用户提供数据的抽象视图,即系统隐藏有关数据存储和维护的某些细节。对数据的管理涉及信息存储结构的定义、信息操作机制的提供、安全性保证,以及多用户对数据的共享问题。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1011.html":{"url":"books/1011.html","title":"数据与数据管理的发展","keywords":"","body":"数据与数据管理的发展--怎么发展 人工管理阶段（1946.2-1955左右） 文件系统阶段（1955-1965） 数据库系统阶段（1965-至今） 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1012.html":{"url":"books/1012.html","title":"信息与数据","keywords":"","body":"信息与数据 信息 信息是现实世界中对客观事物的反映。这种反映主要体现为事物属性的表现形式，是对事物存在方式或运动状态的刻画。 信息的主要特征 • 可传递性：信息是可以传递的，但其传递的前提是必须有载体，且传递过程消耗能量。 • 可感知性:信息可以被人类“感觉”得到的，但感觉的方式可能由于信息源的不同而呈现多样性。 • 可管理性:信息是可以被管理的，我们可以通过一定的方法对信息进行加工、存储、传播、再生和增值等。 数据 数据是描述事务的符号记录，是信息的符号化表示，是信息的载体。 • 数据是信息表示的一种符号形式。这种符号形式可以是语言、图表、数字、声音等。但不管用什么样的符号形式，其目的只有一个，那就是客观地反映信息的内容。信息的内容不会随着数据表现形式的不同而改变。 信息和数据的区分和联系： • 数据是信息的载体，可以有多种表现形式，其目的都是为了揭示信息的内容； • 信息是数据的内涵，它仅由客观事物的属性来确定，而与数据形式无关。 ​ 但在实际应用中，如果不需要特别强调信息和数据的差异，这两个概念往往是互换的。例如，“信息处理”和“数据处理”通常意指有相同内涵的两个概念。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1013.html":{"url":"books/1013.html","title":"数据处理和数据管理","keywords":"","body":"数据处理和数据管理 定义 　　 数据处理 Ø 数据处理也称信息处理，它泛指用计算机对各种类型数据进行的处理操作。 Ø 这些操作包括对数据进行采集、转换、分类、存储、排序、加工、维护、统计和传输等系列活动。 Ø 数据处理的目的是从原始数据中提取有价值的、可作决策依据的信息。 　　 数据管理 Ø 数据管理指在复杂的数据处理过程中的一些基本操作，如数据存储、分类、统计和检索等。 Ø 数据管理是数据处理的任务之一，是数据处理的核心内容，数据库系统的基本功能就是数据管理。 数据管理技术的发展过程 人工管理阶段（1946.2-1955左右） 　　这一阶段主要指是从计算机诞生到20世纪50年代中期的这一个时期。世界上第一台计算机ENIAC于1946年2月14日在美国宾夕法尼亚大学诞生，在随后的近十年中计算机的主要应用是科学计算，处理的是数字数据，数据量不大。 　　计算机没有操作系统（实际上当时根本没有操作系统的概念），也没有数据的管理软件，是以批处理方式对数据进行计算。 　　计算机硬件本身也没有磁盘，所使用的“存储设备”是磁带、卡片等。 人工处理阶段数据管理技术的特点体现在 Ø 数据不保存。一是当时计算机所处理的数据量很小，不需要保存；二是计算机本身就没有有效的存储设备。 Ø 数据缺乏独立性和有效的组织方式。这体现在数据依赖于应用程序，缺乏共享性。其原因在于，数据的逻辑结构跟程序是紧密联系在一起的，程序A处理的数据，对程序B而言可能就无法识别，更谈不上处理。解决的办法是修改数据的逻辑结构，或者修改应用程序。显然，这种数据管理方法仅适用于小量数据，对大量数据则是低效的。 Ø 数据为程序所拥有，冗余度高。由于数据缺乏独立性，一组数据只能为一个程序所拥有，而不能同时为多个程序所共享，这就造成了一份数据的多个拷贝，各程序之间存在大量重复的数据，从而产生大量的冗余数据。 文件系统阶段（1955-1965） 　　 这一阶段是从50年代后期到60年代中期的这一段时间。这个时期，计算机除了用于科学计算以外，还大量用于数据的管理。 　　计算机已经有了操作系统，并且在操作系统之上已经开发了一种专门用于数据管理的软件——文件管理系统。在文件管理系统中，数据的批处理方法发展到了文件的批处理方式，且还可以实现了一定程度的联机实时处理。 　　计算机硬件本身已经出现了磁盘、磁鼓等外部存储设备计算机硬件经出现了磁盘、磁鼓等外部存储设备。 文件系统阶段特点 计算机的应用从单纯的科学计算逐步转移到数据处理，特别是在该阶段的后期，数据处理已经成为计算机应用的主要目的。主要限于对文件的插入、删除、修改和查询等基本操作。 数据按照一定的逻辑结构组成文件，并通过文件实现数据的外部存储。即数据是以文件的方式存储在外部存储设备中，如磁盘、磁鼓等。 数据具有一定的独立性。由于数据是以文件的方式存储，文件的逻辑结构与存储结构可以自由地进行转换，所以多个程序可以通过文件系统对同一数据进行访问，实现了一定程度的数据共享。 文件形式具有多样化，除了数据文件以外还产生了索引文件、链接文件、顺序文件、直接存取文件和倒排文件等。 基本上以记录为单位实现数据的存取。 缺点： Ø 数据和程序并不相互独立，数据冗余度仍然比较大。一个程序基本上是对应着一个或一组文件，即数据还是面向应用的，不同的程序还需建立自己的数据文件，能真正实现数据共享的情况并不多。原因在于，文件中数据的逻辑结构与其对应的程序密切相关，而且没有统一标准的逻辑结构。 Ø 难以保证数据一致性。由于文件之间没有关联机制，所以当对一个数据进行更改时难以保证对该数据的其他副本进行同样的更改。 Ø 文件的数据表达能力十分有限。这主要体现在，文件中的数据结构比较单一，也比较简单，还难以表示复杂的数据结构。 数据库系统阶段（1965-至今） 　　数据库系统阶段始于20世纪60中后期，一直到现在。这时计算机除了用于科学计算以外，更多时候是用于数据管理，而且数据的量已经很大，管理功能也越来越强大。 　　 计算机硬件本身也发生了深刻的变化，出现了大容量磁盘和高主频的CPU等。 　　在软件上，数据的管理软件已经由原来的文件系统上升到了数据库管理系统（DBMS）。 　　数据管理的主要特点是数据集中存放在一个地方，这个地方就是所谓的数据库。应用程序要实现对数据库中的数据进行访问，则必须通过数据库管理系统来完成。 数据库技术是基于数据库的数据管理技术。 其特点： • 数据组织的结构化。从总体上看，文件系统中的数据是“涣散”的，而数据库中的数据是结构化的，具有统一的逻辑结构。数据的结构化是数据库的主要特征之一，是数据库和文件系统的最大和根本的区别。 • 减少数据冗余度，增强数据共享性。从整个系统上看，数据不再面向某一个特定的应用程序，而是面向由所有应用程序组成的系统。所以一个数据可以为多个应用程序所共享，一个应用程序也可以同时访问多个数据。 • 保证数据的一致性。通过建立文件间的关联，使得在对某一个数据进行更新时，与之相关的数据也得到相应更改。 • 具有较高的数据独立性。在数据库系统中，数据独立性包含两个方面，一个是数据的物理独立性，另一个是数据的逻辑独立性。 　　数据的物理独立性是指在数据的物理存储结构发生改变时，数据的逻辑结构可以不变的特性； 　　数据的逻辑独立性是指在总体逻辑结构改变时，应用程序可以不变的一种特性。 　　数据库之所以具有较好的数据独立性，主要是因为数据库提供了两个映象功能：数据的存储结构和逻辑结构之间的映象或转换功能以及数据的总体逻辑结构和局部逻辑结构之间的映象功能。前者保证了数据的物理独立性，后者则保证了数据的逻辑独立性。 • 以数据项为单位进行数据存取。相对文件系统而言，数据库可以实现更小粒度的数据处理，满足更多的应用需求。 • 具有统一的数据控制功能。这些功能包括数据的安全性控制、完整性控制、并发控制和一致性控制等功能。 　　数据管理技术发展的这三个阶段是一个渐进的过程，它们的区别主要体现在应用程序和数据的关系上： Ø 在人工管理阶段，应用程序和数据是“混合”在一起； Ø 在文件系统阶段，应用程序则通过文件系统完成对数据的访问，实现了数据和程序一定程度的分离； Ø 在数据库系统阶段，应用程序是通过数据库管理系统（DBMS）对数据进行访问，实现了数据和程序的高度分离。 三个阶段之间的关系表示: 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1014.html":{"url":"books/1014.html","title":"大数据分析与管理技术","keywords":"","body":"大数据分析与管理技术 关于大数据 　　2008年，英国著名学术杂志《Nature》上推出了大数据的专刊。 　　美国一些知名数据管理领域的专家从专业角度出发联合发布了一份名为《大数据的机遇与挑战》（Challenges and opportunities with big data）的白皮书，从学术角度介绍了大数据的产生、处理流程和所面临的若干挑战。 　　在工业界，全球知名的咨询公司麦肯锡公司（McKinsey）2011年也发表了一份名为《大数据：下一个创新、竞争和生产力的前沿》（Big Data: the next frontier for innovation, competition and productivity）的详尽报告，对大数据带来的巨大影响、关键技术和应用领域进行了详尽阐述和分析。 　　美国奥巴马政府更是在2012年发布了“大数据研究和发展倡议”（Big data research and development initiative），斥资2亿多美元计划在科研、环境、生物医学等领域利用大数据分析管理技术取得新的突破。我国政府也于2015年发布了《中共中央关于制定国民经济和社会发展第十三个五年规划的建议》提出实施国家大数据战略，超前布局下一代互联网。 　　目前“大数据”（Big data）已成为一个炙手可热的名词。从表面上看，其表示数据规模的庞大，但仅仅从数据规模上无法区分“大数据”这一概念和以往的“海量数据”（Massive data）和“超大规模数据”（Very large data）等概念的区别。然而，至今仍没有一个对“大数据”公认的准确定义。 根据维基百科的解释，大数据指的是数据规模巨大到无法通过目前主流的软件工具在合理时间内完成处理的数据集。由此可见，随着时间的推移，计算机的计算能力、存储能力会不断提升，因此大数据的含义也会不断演化。 今天所说的大数据在未来可能就不算“大”了，但那时也一定仍会存在更大的数据是当时的技术处理不了的，因而仍会被称为大数据。可见，如何驾驭大数据将会成为人们长期需要面对的数据常态。 　　大数据的“4V”特性： （1）体量大（Volume）。大数据体现在数据量极为庞大，其计量单位可以是TB级、PB级甚至更大的计量单位。 （2）速度快（Velocity）。大数据呈现出高速增长的态势，而且产生速度仍在不断加快。 （3）多样化（Variety）。大数据包含多种多样的数据类型，既可以是存储在二维表中的结构化数据，也可以是文本、视频、图像、语音、图（Graph）、文件等非结构化数据。 （4）价值高（Value）。大数据中蕴藏着巨大价值，但价值密度低。通过对大数据进行合理的分析，能够从中挖掘出很多有价值的信息，这些信息将有助于提高社会生产效率，提升人们生活质量，或者创造更大商业价值。 大数据存储技术 ​ 随着大数据时代的到来，传统关系型数据库的发展面对大数据时代的数据管理需求越来越力不从心，主要体现在： • 无法保证对大数据的查询效率：在大数据时代，短短的1分钟时间内新浪微博可以产生2万条微博，苹果可以产生4.7万次应用下载记录，淘宝则可以卖出6万件商品，百度可以产生90万次搜索记录。可见对于上述公司而言很快就会积累超过10亿的数据量。然而，由于关系模型严谨得过于死板，例如复杂的事务处理机制就成为了阻碍其性能提升的桎梏，使得传统关系型数据库在一张包含10亿条记录的数据表之上进行SQL查询时效率极低。 • 无法应对繁多的数据类型：关系型数据库存储的是清洁规整的结构化数据，然而在大数据时代，数据种类繁多，包括文本、图片、音频和视频在内的非结构化数据所占比重更是超过了90%，这无疑是关系型数据库所不能应对的。 • 横向可扩展能力不足：传统关系型数据库由于自身设计机理的原因，通常很难实现性价比较高的“横向扩展”，即基于普通廉价的服务器扩充现有分布式计算系统，使系统的处理能力和存储能力得到提升。而“横向扩展”是大数据时代计算和存储的重要需求。 • 很难满足数据高并发访问需求：大数据时代诸如购物记录、搜索记录、朋友圈消息等信息都需要实时更新，这就会导致高并发的数据访问，可能产生每秒高达上万次的读写请求。在这种情况下，传统关系型数据库引以为傲的事务处理机制和包括语法分析和性能优化在内的查询优化机制却阻碍了其在并发性能方面的表现。 　　在以上大数据时代的数据管理需求的推动下，各种新型的NoSQL数据库不断涌现，一方面弥补了关系型数据库存在的各种缺陷，另一方面也撼动了关系型数据库的传统垄断地位。 　　NoSQL（Not only SQL）不是指某个具体的数据库，是对非关系型数据库的统称。 　　NoSQL数据库采用类似键/值、列族、文档和图（Graph）等非关系数据模型，通常没有固定的表结构，没有复杂的查询优化机制，也没有严格的事务ACID特性的约束，因此和关系型数据库相比，NoSQL数据库具有更优秀的查询效率，更灵活的横向可扩展性和更高并发处理性，并能够存储和处理非结构化数据。 　　根据所采用的数据模型的不同，NoSQL数据库具体又可以分为以下四类： • 键值（Key-Value）存储数据库。这一类数据库主要使用哈希表作为数据索引，哈希表中有一个特定的键和一个指针指向特定的数据。这种数据库的优势是简单、易部署、查询速度快；缺点是数据无结构，通常只被当作字符串或者二进制数据。Tokyo Cabinet/Tyrant、Redi、Voldemort、Oracle BDB等都属于这一类数据库。 • 列存储数据库。这类数据库通常用来应对分布式存储海量数据的存储需求。在列存储数据库中，数据以列簇式存储，将同一列数据存在一起。这种数据库的优点是查找速度快，可扩展性强，更容易进行分布式扩展；缺点是功能相对局限。Cassandra、HBase、Riak等属于这一类数据库。 • 文档型数据库。这类数据库与键值存储数据库类似，数据按键值（Key-Value）存对的形式进行存储，但与键值存储数据库不同的是，Value为结构化数据。这类数据库适用于Web应用。文档型数据库的优点是对数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构；缺点是查询性能不高，缺乏统一的查询语法。uCouchDB、MongoDB等属于这一类数据库。 • 图（Graph）数据库。这类数据库专注于构建关系图谱，存储图结构数据，适用于社交网络、推荐系统等。图数据库的优点是能够直接利用图结构相关算法，如最短路径寻址、N度关系查找等；缺点是很多时候需要对整个图做计算才能得出需要的信息。Neo4J、InfoGrid、Infinite Graph等属于这一类数据库。 　　NoSQL数据库不受关系模型约束，具有较好的扩展性，很好地弥补了传统关系型数据库的缺陷。但NoSQL数据库并没有一个统一的架构，每一类NoSQL数据库都有各自适用的场景。同时，NoSQL数据库不能严格保证事务的ACID特性，导致数据的一致性和正确性没法保证。而且NoSQL数据库缺乏完备系统的查询优化机制，在复杂查询方面的效率不如关系型数据库。为此，业界又提出了NewSQL数据库。 　　NewSQL 数据库是对各种新的可扩展、高性能数据库的简称，这类数据库不仅具有NoSQL对海量数据的存储管理能力，还保持了传统数据库支持事务ACID和SQL等特性。 　　不同NewSQL数据库的内部架构差异较大，但是有两个共同的特点：都支持关系数据模型；都是用SQL作为其主要的访问接口。 　　目前市面上已有的NewSQL数据库有Spanner、PostgreSQL、SAP HANA、VoltDB、MemSQL等。 Ø Spanner是谷歌公司研发的、可扩展的、多版本、全球分布式、同步复制数据库，是谷歌公司第一个可以全球扩展并支持数据外部一致性的数据库。 Ø PostgreSQL是很受欢迎的开源数据库，稳定性强，有大量的几何、字典、数组等数据类型，在地理信息系统领域处于优势地位。 Ø SAP HANA基于内存计算技术，是面向企业分析性应用的产品，主要包括内存计算引擎和HANA建模工具两部分。 Ø VoltDB是基于内存的关系型数据库，其采用NewSQL体系架构，既追求与NoSQL体系架构系统具有相匹配的系统可展性，又维护了传统关系型数据库系统的事务特性和SQL语言访问特性，在执行高速并发事务时比传统的关系型数据库系统快45倍。 Ø MemSQL有符合ACID特性的事务处理功能、SQL兼容性以及高度优化的SQL存储引擎，提供了与MySQL相同的编程接口，但速度比MySQL快30倍。 Ø 还有一些在云端提供存取服务的NewSQL数据库（亦可称为云数据库），例如Amazon RDS和Microsoft SQL Azure。 大数据处理模式 　　大数据具有数据体量大、产生速度快的特点，因而传统的单机串行处理模式往往难以完成对大数据的高效处理，必须借助并行分布式处理方法。根据大数据应用类型的不同，大数据处理模式分为批处理（Batch processing）和流处理（Stream processing）两种。下面以Apache的Hadoop和Storm为例分别介绍批处理和流处理的典型处理模式。 分布式批处理模式的代表——Hadoop 　　批处理则是对数据先存储后统一处理。Hadoop是一个由Apache基金会用Java语言开发的开源分布式批处理架构，其中实现了MapReduce批处理编程模型。Google公司在2004年提出的MapReduce编程模式是最具代表性的分布式数据批处理模式。 　　MapReduce模型包含三种角色：Master进程、Map进程和Reduce进程，其中Master进程负责任务的划分与调度，Map进程用于执行Map任务，Reduce进程用于执行Reduce任务。该模型的主要思想是Master进程把大规模的数据划分成多个较小的部分，分别映射到多个Map进程进行并行处理得到中间结果，之后由Reduce进程对这些中间结果进行规约、整理，进而得到最终结果，如图1.4所示。 　　一个MapReduce作业（MapReduce Job）的执行流程如下： （1）首先从用户提交的程序创建出Master进程，Master进程启动后划分任务并根据输入文件所在位置和集群信息选择机器创建出Map进程或Reduce进程； （2）Master进程将划分好的任务分配给Map进程和Reduce进程执行，任务划分和任务分配可以并行执行； （3）Map进程执行Map任务，即读取相应的输入文件，根据指定的输入格式不断地读取对，并对每一个对执行用户自定义的Map函数； （4）Map进程不断往本地内存缓冲区输出中间对结果，等到缓冲区超过一定大小时写入到本地磁盘中，Map进程将中间结果组织成文件，便于后续Reduce进程获取； （5）Map任务执行完成后向Master进程汇报，Master进程进一步将该消息通知Reduce进程。Reduce进程向Map进程请求传输生成的中间结果数据，当Reduce进程获取完所有的中间结果后，需要进行排序操作； （6）Reduce进程执行Reduce任务，即对中间结果的每一个相同的key及value集合，执行用户自定义的Reduce函数，Reduce函数的输出结果被写入到最终的输出文件。 　　除了使用MapReduce批处理编程框架，Hadoop的核心内容还包括HDFS（Hadoop Distributed File System，Hadoop分布式文件系统）。 　　HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，适合处理大规模数据集的应用程序。 　　Hadoop的优点包含以下几个方面： （1）方便部署。Hadoop可以方便部署在由一般商用机器构成的大型集群或者云计算服务之上。 （2）容错健壮。即使集群中的计算机硬件频繁出现失效，Hadoop也能够处理大多数此类故障。 （3）容易扩展。Hadoop通过增加集群节点，可以线性地扩展以处理更大的数据集。 （4）使用简单。Hadoop允许用户快速编写出高效的并行代码。 （5）免费、开源。Hadoop是一款开源批处理框架，可以免费使用。 ​ Hadoop的典型应用包括网络搜索、日志处理、推荐系统、数据分析、视频图像分析和数据集成等。 分布式流处理模式的代表——Storm 　　和先存储再处理的批处理模式不同，流处理将源源不断产生的数据视为数据流，每当新的数据到达系统时就立刻对数据进行处理并返回结果。可见，流处理适合包括网页点击数统计、股票交易数据分析和传感器网络事件检测等实时分析应用。Apache Storm是一个免费、开源的分布式实时流处理系统。Storm在流处理中的地位相当于Hadoop对于批处理的重要地位。 　　Storm基于拓扑（Topology）实现对数据流的分布式实时处理。拓扑是一个有向无环图（Directed Acyclic Graph），一个典型的Storm的拓扑结构如图1.5所示。 　　Topology中数据以元组（Tuple）的形式进行转发和处理。和Hadoop中的MapReduce作业不同，Storm的拓扑一经启动将永久运行，不断处理实时到达的数据元组。 　　Storm拓扑由Spout和Bolt两类组件构成。Spout作为数据产生者，从一个外部源（例如Kafka）读取数据并并向Storm拓扑中喷射数据元组。Bolt作为数据消费者，对所接收的数据元组进行处理和转发。 　　一个复杂的Storm拓扑可由多个Spout和多个Bolt组成，且可以为每个Spout或Bolt设置其任务（Task）并行度，由多个任务并行完成其处理逻辑。Storm提供多种组件间的数据分发策略，例如随机分组（Shuffle grouping）、按字段分组（Field grouping）、全局分组（Global grouping）和广播发送（All grouping），用以完成Storm拓扑中上游组件的各个任务向下游组件的各个任务的数据分发. 　　Storm的优点包含以下几个方面： （1）易整合：Storm可以方便与数据库系统进行整合。 （2）易使用：Storm提供丰富的API，方便用户的使用。 （3）易扩展：Storm可以方便部署和运行在大规模分布式集群中。 （4）易纠错：Storm可以自行重启故障节点，并完成对故障节点任务的重新分配。 （5）可靠的消息处理：Storm保证每个消息都能被系统完整处理。 （6）免费、开源：Storm是一款开源流处理框架，可以免费使用。 大数据处理的基本流程 1. 数据集成 ​ 大数据的一个重要特性就是多样化（Variety），这意味着产生大数据的来源广泛、类型庞杂、并经常存在数据冗余和错漏现象，给数据处理带来了巨大挑战。要想处理大数据，首要任务就是对数据源抽取的数据进行合理的集成。 ​ 数据集成是指通过访问、解析、规范化、标准化、整合、清洗、抽取、匹配、分类、修饰和数据交付等功能把不同来源、格式、特点、性质的数据在逻辑上或物理上有机地集中，从而为后期数据处理提供保障。数据集成的目的是保证数据的质量和可信性。如果数据集成工作没有做好，会导致整个大数据项目的延期甚至失败。因此，在大数据给人们带来价值之前，必须对其进行合理的集成。 2. 数据分析 ​ 数据分析是整个大数据处理流程中的核心环节，因为大数据所蕴含的价值需要通过数据分析得以实现。传统的数据分析技术包括数据挖掘、机器学习、统计分析等在用于处理大数据时可能需要进行必要的调整，因为这些技术在处理大数据时面临一些新的挑战，体现在以下几个方面： 　　大数据价值大（Value）的特性虽然意味着大数据蕴含了巨大价值，但是大数据同时也存在价值密度低的特点，体现在大数据中存在大量的冗余数据、噪音数据、遗漏数据和错误数据。因此，在进行数据分析之前，需要对大数据进行数据清洗、整合等集成工作。然而，对如此大规模的数据进行清洗和整合无疑会对硬件环境和算法性能提出新的要求。 3. 数据解释 ​ 虽然数据分析是大数据处理的核心，但是用户更关注对分析结果的展示。即使分析过程高效、分析结果正确，如果没有通过容易理解的方式给用户展示大数据的分析结果将会大大降低分析结果的实际价值，极端情况下甚至会误导用户。 ​ 传统的数据解释方法是在电脑终端上打印显示分析结果或以文本的形式向用户呈现分析结果。然而，大数据的分析结果往往规模大而且结果之间的关系错综复杂，因而传统的数据解释方法不适用于解释大数据的分析结果。 ​ 目前，业界推出了很多数据可视化技术，用图表等形象的方式向用户展现大数据的分析结果。常见的数据可视化技术包括标签云（Tag cloud）、历史流（History flow）和空间信息流（Spatial information flow）等。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1015.html":{"url":"books/1015.html","title":"数据库系统概述--已有设计","keywords":"","body":"数据库系统概述--怎么存（已有方案） 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1062.html":{"url":"books/1062.html","title":"数据库与数据库管理系统","keywords":"","body":"数据库与数据库管理系统 1.数据库系统 1.1定义 　　数据库系统是以数据库技术为核心的计算机应用系统，其主要目的是处理生产和实践过程中产生的数据和信息，实现生产过程管理的自动化和信息化，提高信息管理效率。 　　数据、数据库、数据库管理系统与操作数据库的应用程序，加上支撑它们的硬件平台、软件平台和与数据库有关的人员一起构成了一个完整的数据库系统。下图描述了数据库系统的构成。 数据库系统的构成 1.2组成 数据库系统一般包含四个部分 1.2.1数据库 定义：是数据库系统存放结构化数据的地方，是长期存储的、有组织的、可共享的数据的集合。 Ø 数据最终是以文件的形式存储在磁盘上，只有数据库管理系统才能对这些文件进行存取操作。 Ø 每一个数据库都至少有一个这样文件，称为数据文件。 Ø SQL Server数据库的数据文件以.mdf或.ndf为扩展名。 数据库（DB）是存放数据的仓库，只不过这些数据存在一定的关联，并按一定的格式存放在计算机内。广义上讲，数据不仅包含数字，还包括文本、图像、音频、视频等。 例如，把一个学校的学生、课程、学生成绩等数据有序地组织并存放在计算机内，就可以构成一个数据库。 因此，数据库由一些持久的相互关联的数据的集合组成，并以一定的组织形式存放在计算机的存储介质中。 1.2.2数据库管理系统(DBMS) 　　定义: DBMS是数据库的管理软件，是应用程序和数据库之间桥梁，即应用程序必须通过DBMS才能存取数据库中的数据。 Ø DBMS对数据的存取操作最终体现为对数据文件的更新和修改，但应用程序不能直接执行这种更新和修改操作。 Ø SQL Server 2014就是SQL Server数据库系统的一种DBMS。 　　数据库管理系统（DBMS）是管理数据库的系统，它按一定的数据模型组织数据。DBMS应提供如下功能： （1）数据定义功能：可定义数据库中的数据对象。 （2）数据操纵功能：可对数据库表进行基本操作，如插入、删除、修改、查询等。 （3）数据的完整性检查功能：保证用户输入的数据满足相应的约束条件。实体、参照、域（用户定义）完整性 （4）数据库的安全保护功能：保证只有具有权限的用户才能访问数据库中的数据。 （5）数据库的并发控制功能：使多个应用程序可在同一时刻并发地访问数据库的数据。 （6）数据库系统的故障恢复功能：使数据库在运行出现故障时进行数据库恢复，以保证数据库可靠运行。 （7）在网络环境下访问数据库的功能。 （8）方便、有效地存取数据库信息的接口和工具。编程人员通过程序开发工具与数据库的接口编写数据库应用程序。数据库系统管理员（DBA，DataBase Adminitrator）通过提供的工具对数据库进行管理。 1.2.3应用程序 定义: 是指通过访问数据库来完成用户操作的程序。 Ø 它介于系统用户和DBMS之间，用户通过操作应用程序来获取他们的需求，而应用程序则通过DBMS访问数据库来实现用户提出的需求。 Ø 应用程序可以用Java、JSP、.NET等技术开发。 1.2.4系统用户 定义:是大致分为两类——系统用户和系统管理员。 Ø 系统用户是指应用程序的用户，他们是整个数据库系统的最终使用者； Ø 系统管理员可以分为不同级别类型的管理人员，他们主要负责数据库的管理和维护工作。 1.2.5数据库系统各部分之间的关系 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1063.html":{"url":"books/1063.html","title":"功能-管理系统","keywords":"","body":"功能-管理系统 　　DBMS的功能主要包括以下几个方面： 1.数据库定义功能 可定义数据库中的数据对象。 　　DBMS一般都提供数据定义语言（DDL, Data Definition Language），可以分别用于定义外模式、概念模式和内模式。用DDL编写的外模式、概念模式和内模式分别称为源外模式、源概念模式和源内模式。它们经过模式翻译程序翻译后将形成相应的内部表示，分别称为目标外模式、目标概念模式和目标内模式。 　　这些目标模式被保存在数据字典中（又称系统目录），它们是用于刻画数据库的框架结构，是对数据库（而不是数据）的一种描述，也是DBMS存取和管理数据的基本依据。 2.数据操纵功能 　　可对数据库表进行基本操作，如插入、删除、修改、查询等。 ​ DBMS还提供数据操作语言(DML, Data Manipulation Language)用于实现对数据库的查询、添加、修改和删除等基本操作。 　　DML分为宿主型的和自主型的（或自含型的）的DML。 Ø 宿主型的DML用于嵌入到其他语言（称为主语言）当中，例如把它嵌入到PASCAL、FORTRAN，C等高级语言中。这类DML语言本身不能独立使用，这也就是它之所以称为宿主型DML的原因。 Ø 自主型的（或自含型）DML则是交互式命令语言，其语法简单，每条语句都可以独立执行。 Ø 如今，DBMS一般既提供宿主型的DML也提供自主型的DML，或者提供集宿主型和自主型于一体的DML，其典型的代表就是著名的SQL（Structured Query Language）语言。SQL语句既可以嵌入到其他的高级语言，也可以单独交互执行。 　　用户或者应用程序对数据库的操作实际上是通过DBMS控制并执行DML语句来实现的。 　　自主型的DML是交互式命令语言，DBMS通常以解释执行的方式运行它们。 　　对于宿主型的DML，DBMS提供两种执行方法： Ø 预编译方法。这种方法的原理是，由DBMS提供的预编译程序对包含DML的主语言进行扫描，识别出DML，然后把这些DML转换成合法的主语言代码，以便主语言的编译程序能够接受和执行它们。 Ø 修改、扩充主语言编译程序的方法。这种方法又称为增强编译方法，增强后的编译程序既可以编译主语言代码，也可以编译和执行嵌入的DML语句。 3.数据库运行管理功能 　　数据库运行管理是DBMS提供的重要功能之一，它是数据系统能够正确、有效运行的基本保证。这种管理功能主要包括存取控制、安全性检测、并发控制、完整性约束条件的检查和执行、数据库内部的维护和管理等。 ​ 数据库在运行期间多用户环境下的并发控制、安全性检査和存取控制、完整性检查和执行、运行日志的组织管理、事务管理和自动恢复等是 DBMS 的重要组成部分,这些功能可以保证数据库系统的正常运行。 4.数据的组织、存储和管理 DBMS 分类组织、存储和管理各种数据,包括数据字典、用户数据和存取路径等。因此要确定以何种文件结构和存取方式在存储级上组织这些数据,以提高存取效率。实现数据间的联系、数据组织和存储的基本目标是提高存储空间的利用率。 5.数据库的建立和维护功能 　　这包括数据库初试数据的装载和转换、数据库的转储和恢复、数据库的重组织功能和性能监视、分析功能等。这些功能主要是由DBMS提供的实用程序来完成。 6.其他功能 其他功能包括: DBMS 的网络通信功能,一个 DBMS 与另一个 DBMAS 或文件系统的数据转换功能,异构数据库之间的互访和互操作能力等。 数据库管理系统 数据库管理系统（DBMS）是管理数据库的系统，它按一定的数据模型组织数据。DBMS应提供如下功能： （1）数据定义功能：可定义数据库中的数据对象。 （2）数据操纵功能：可对数据库表进行基本操作，如插入、删除、修改、查询等。 （3）数据的完整性检查功能：保证用户输入的数据满足相应的约束条件。 （4）数据库的安全保护功能：保证只有具有权限的用户才能访问数据库中的数据。 （5）数据库的并发控制功能：使多个应用程序可在同一时刻并发地访问数据库的数据。 （6）数据库系统的故障恢复功能：使数据库在运行出现故障时进行数据库恢复，以保证数据库可靠运行。 （7）在网络环境下访问数据库的功能。 （8）方便、有效地存取数据库信息的接口和工具。编程人员通过程序开发工具与数据库的接口编写数据库应用程序。数据库系统管理员（DBA，DataBase Adminitrator）通过提供的工具对数据库进行管理。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1064.html":{"url":"books/1064.html","title":"特征及分类-管理系统","keywords":"","body":"特征及分类-管理系统 DBMS的特征 通过 DBMS 来管理数据具有以下特点。 (1) 数据结构化且统一管理。 数据库中的数据由 DBMS 统一管理。由于数据库系统采用复杂的数据模型表示数据结构,数据模型不仅描述数据本身的特点,还描述数据之间的联系。数据不再面向某个应用,而是面向整个应用系统。数据易维护、易扩展,数据冗余明显减少,真正实现了数据的共享。 (2) 有较高的数据独立性。 数据的独立性是指数据与程序独立,将数据的定义从程序中分离出去,由 DBMS 负责数据的存储,应用程序关心的只是数据的逻辑结构,无须了解数据在磁盘上的数据库中的存储形式,从而简化应用程序,大大减少了应用程序编制的工作量。数据的独立性包括数据的物理独立性和数据的逻辑独立性。 (3) 数据控制功能。 DBMS 提供了数据控制功能,以适应共享数据的环境。数据控制功能包括对数据库中数据的安全性、完整性、并发和恢复的控制。 1 数据库的安全性。 数据库的安全性( Security )是指保护数据库以防止不合法的使用所造成的数据泄漏、更改或破坏。这样,用户只能按规定对数据进行处理,例如,划分了不同的权限,有的用户只能有读数据的权限,有的用户有修改数据的权限,用户只能在规定的权限范围内操纵数据库。 2 数据的完整性。 数据库的完整性是指数据库的正确性和相容性,是防止合法用户使用数据库时向数据库加入不符合语义的数据,保证数据库中的数据是正确的,避免非法的更新。 3 并发控制。 在多用户共享的系统中,许多用户可能同时对同一数据进行操作 。DBMS的并发控制子系统负责协调并发事务的执行,保证数据库的完整性不受破坏,避免用户得到不正确的数据。 4故障恢复。 数据库中的4类故障是事务内部故障、系统故障、介质故障及计算机病毒。故障恢复主要指恢复数据库本身,即在故障引起数据库当前状态不一致时将数据库恢复到某个正确状态或一致状态。恢复的原理非常简单,就是要建立冗余( Redundancy )数据。换句话说,确定数据库是否可恢复的方法就是其包含的每一条信息是否都可以利用冗余存储在别处的信息重构。冗余是物理级的,通常认为逻辑级是没有冗余的。 DBMS的分类 DBMS 通常可分为以下三类。 (1) 关系数据库系统 (Relation DataBase Systems , RDBS )。 关系数据库系统是建立在关系数据库模型基础上的数据库,借助于集合代数等概念和方法来处理数据库中的数据。目前主流的关系数据库有 Oracle 、 Db 2、 Sybase、Microsoft SQL Server、Microsoft Access、MySQL等。在关系模型中,实体以及实体间的联系都是用关系来表示的。在一个给定的现实世界领域中,相应的所有实体及实体之间联系的关系的集合构成一个关系数据库,也有型和值之分。关系数据库的型也称为关系数据库模式,它是对关系数据库的描述,是关系模式的集合。关系数据库的值也称为关系数据库,是关系的集合。关系数据库模式与关系数据库通常统称为关系数 据库。 (2) 面向对象的数据库系统( Object-Oriented DataBase System , OODBS )。 面向对象的数据库系统是支持以对象形式对数据建模的数据库管理系统,包括对对象的类、类属性的继承和子类的支持。面向对象数据库系统主要有两个特点:一是面向对象数据模型能完整地描述现实世界的数据结构,能表达数据间的嵌套、递归联系;二是具有面向对象技术的封装性和继承性提高了软件的可重用性。 (3) 对象关系数据库系统( Object-Oriented Relation DataBase System , ORDBS） 对象关系数据库系统是在传统的关系数据模型基础上提供元组、数组、集合等更为丰富的数据类型以及处理新的数据类型操作的能力,这样形成的数据模型被称为“对象关系数据模型”,基于对象关系数据模型的 DBS 称为对象关系数据库系统。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1065.html":{"url":"books/1065.html","title":"体系结构-数据库系统","keywords":"","body":"体系结构-数据库系统 数据库系统是数据密集型应用的核心,其体系结构受数据库运行所在的计算机系统的影响很大,尤其是受计算机体系结构中的连网、并行和分布的影响。从不同的角度或不同层次上看,数据库系统体系结构不同;从最终用户的角度看,数据库系统体系结构分为集中式、分布式、c/s(客户端务器)和并行结构;从数据库管理系统的角度看,数据库系统体系结构一般采用三级模式结构。 1.集中式数据库系统 分时系统环境下的集中式数据库系统结构诞生于20世纪60年代中期。当时的硬件和操作系统决定了分时系统环境下的集中式数据库系统结构成为早期数据库技术的首选结构。在这种系统中,不仅数据是集中的,数据的管理也是集中的,数据库系统的所有功能(从形式的用户接口到 DBMS 核心)都集中在 DBMS 所在的计算机上,如图9-1所示。大多数关系 DBMS 的产品也是从这种系统结构开始发展的,目前这种系统还在使用。 2.客户端/服务器结构 随着网络技术的迅猛发展,很多现代软件都釆用客户端/服务器体系结构,如图9-2所示。在这种结构中,一个处理机(客户端)的请求被送到另一个处理机(服务器)上执行。其主要特点是客户端与服务器 CPU 之间的职责明确,客户端主要负责数据表示服务,服务器主要负责数据库服务。釆用客户端/服务器结构后,数据库系统功能分为前端和后端。前端主要包括图形用户界面、表格生成和报表处理等工具;后端负责存取结构、查询计算和优化、并发控制以及故障恢复等。前端与后端通过 SQL 或应用程序来接口 。ODBC (开放式数据库互连)和 JDBC( Java 程序数据库连接)标准定义了应用程序和数据库服务器通信的方法,即定义了应用程序接口,应用程序用它来打开与数据库的连接、发送查询和更新以及获取返回结果等。 数据库服务器一般可分为事务服务器和数据服务器。 (1)事务服务器。事务服务器也称查询服务器。它提供一个接口,使得客户端可以发出执行一个动作的请求,服务器响应客户端请求,并将执行结果返回给客户端。用户端可以用 SQL ,也可以通过应用程序或使用远程过程调用机制来表达请求。一个典型的事务服务器系统包括多个在共享内存中访问数据的进程,包括服务器进程、锁管理进程、写进程、监视进程和检查点进程。 (2)数据服务器。数据服务器系统使得客户端可以与服务器交互,以文件或页面为单位对数据进行读取或更新。数据服务器与文件服务器相比提供更强的功能,所支持的数据单位可以比文件还要小,如页、元组或对象;提供数据的索引机制和事务机制,使得客户端或进程发生故障时数据也不会处于不一致状态。 3.并行数据库系统 并行体系结构的数据库系统是多个物理上连在一起的 CPU ,而分布式系统是多个地理上分开的 CPU 。并行体系结构的数据库类型分为共享内存式多处理器和无共享式并行体系结构。 1) 共享内存式多处理器 共享内存式多处理器是指一台计算机上同时有多个活动的 CPU ,它们共享单个内存和一个公共磁盘接口,如图9-3所示。这种并行体系结构最接近于传统的单 CPU 处理器结构,其设计的主要挑战是用N个 CPU 来得到N倍单 CPU 的性能。但是,由于不同的 CPU 对公共内存的访问是平等的,这样可能会导致一个 CPU 访问的数据被另一个 CPU 修改,所以必须要有特殊的处理。然而,由于内存访问采用的是一种高速机制,这种机制很难保证进行内存划分时不损 失效率,所以这些共享内存访问问题会随着 CPU 个数的增加变得难以解决。 2) 无共享式并行体系结构 无共享式并行体系结构是指一台计算机上同时有多个活动的 CPU ,并且它们都有自己的内存和磁盘,如图9-4所示,图中粗线表示高速网络。在不产生混淆的情况下,该结构的数据库系统也称为并行数据库系统。各个承担数据库服务责任的 CPU 划分它们自身的数据,通过划分的任务以及通过每秒兆位级的高速网络通信完成事务查询。 4.分布式数据库系统 分布式 DBMS 包括物理上分布、逻辑上集中的分布式数据库结构和物理上分布、逻辑上分布的分布式数据库结构两种。前者的指导思想是把单位的数据模式(称为全局数据模式)按数据来源和用途合理地分布在系统的多个结点上,使大部分数据可以就地或就近存取。数据在物理上分布后,由系统统一管理,使用户不感到数据的分布。后者一般由两部分组成:一是本结点的数据模式,二是本结点共享的其他结点上有关的数据模式。结点间的数据共享由双方协 商确定。这种数据库结构有利于数据库的集成、扩展和重新配置。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1066.html":{"url":"books/1066.html","title":"三级模式-数据库","keywords":"","body":"三级模式-数据库 1.1 数据库系统的模式结构 　　现在数据库系统软件产品非常多，它们可能基于不同的操作系统，支持不同的数据库语言，采用不同的数据结构，等等。但是，它们的体系结构却基本相同，那就是三级模式结构。 　　三级模式结构是由美国国家标准学会（ANSI, American National Standards Institute）所属的标准计划和要求委员会（SPARC, Standards Planning And Requirements Committee）于1975年提出的，称为SPARC分级结构。 　　三级模式结构将数据库系统抽象为三个层次，分别为内模式、概念模式和外模式。 实际上,数据库的产品很多,它们支持不同的数据模型,使用不同的数据库语言,建立在不同的操作系统上。数据的存储结构也各不相同,但体系结构基本上都具有相同的特征,采用“三级模式和两级映像”,如图9-5所示。 数据库系统采用三级模式结构,这是数据库管理系统内部的系统结构。数据库有“型”和“值”的概念,“型”是指对某一数据的结构和属性的说明,“值”是型的一个具体赋值。 数据库系统设计员可以在视图层、逻辑层和物理层对数据进行抽象,通过外模式、概念模式和内模式来描述不同层次上的数据特性。 1.1.1内模式 　　定义:又称存储模式，它是数据在数据库系统中最底层的表示，描述了数据的物理结构和存储方式，即定义了存储记录的类型、存贮域的表示、存储记录的物理顺序、索引等。 　　一个数据库仅有一个内模式。 内模式也称存储模式,是数据物理结构和存储方式的描述,是数据在数据库内部的表示方式,定义所有的内部记录类型、索引和文件的组织方式,以及数据控制方面的细节。例如,记录的存储方式是顺序存储,按照 B 树结构存储,还是 Hash 方法存储;索引按照什么方式组织;数据是否压缩存储,是否加密;数据的存储记录结构有何规定。 描述内模式的数据定义语言称为“内模式 DDL ”。注意,内部记录并不涉及物理记录,也不涉及设备的约束。它比内模式更接近于物理存储和访问的那些软件机制,是操作系统的一部分(即文件系统)。例如,从磁盘上读、写数据。 总之,数据按外模式的描述提供给用户,按内模式的描述存储在磁盘上,而概念模式提供了连接这两级模式的相对稳定的中间层,并使得两级中任意一级的改变都不受另一级影响。 怎么存储 1.1.2概念模式 　　定义:又称逻辑模式，简称模式，它用于对整个数据库中数据的逻辑结构和特征、实体及其性质与联系进行描述。但这种描述并不涉及具体的物理存储方式和硬件环境，也不涉及任何特定的应用程序及其开发工具。 　　一个数据库也只有一个概念模式。 概念模式也称模式,它是数据库中全部数据的逻辑结构和特征的描述,由若干个概念记录类型组成,只涉及型的描述,不涉及具体的值。概念模式的一个具体值称为模式的一个实例,同一个模式可以有很多实例。概念模式反映的是数据库的结构及其联系,所以是相对稳定的;而实例反映的是数据库某一时刻的状态,所以是相对变动的。 需要说明的是,概念模式不仅要描述概念记录类型,还要描述记录间的联系、操作以及数据的完整性和安全性等要求。但是,概念模式不涉及存储结构、访问技术等细节。只有这样,概念模式才算做到了 “物理数据独立性”。描述概念模式的数据定义语言称为“模式 DDL (Schema Data Definition Language )”。 怎么设计 1.1.3外模式 　　定义:外模式是概念模式的一个子集，这个子集是为某一个特定用户所使用的。从这个角度看，外模式是面向用户的，所以外模式又称子模式或用户模式。本质上，外模式是应用程序所使用的局部数据的逻辑结构和特征的描述，是使用该应用程序的用户所看到的数据视图。 外模式也称用户模式或子模式,是用户与数据库系统的接口,是用户用到的那部分数据的描述。它由若干个外部记录类型组成。用户使用数据操纵语言对数据库进行操作,实际上是对外模式的外部记录进行操作。 描述外模式的数据定义语言称为“外模式 DDL ”。有了外模式后,程序员不必关心概念模式,只与外模式发生联系,按外模式的结构存储和操纵数据。 怎么给用户看 1.2总结 　　 以上三个模式分别从三个不同层次的级别对数据库进行抽象，即分别抽象为用户级、概念级、物理级数据库。 Ø 用户级数据库对应于外模式，是从用户的角度对数据库进行抽象，是用户看到和使用的用户视图的集合。 Ø 概念级数据库对应于概念模式，介于用户级和物理级之间，是程序开发人员看到和使用的数据库。。 Ø 物理级数据库对应于内模式，是从数据的物理存储结构的角度对数据库进行抽象。 总之，外模式是概念模式的子集，概念模式是内模式的逻辑表示，而内模式则是概念模式的物理表示。 　　三级模式结构将数据库系统抽象为三个层次，分别为内模式、概念模式和外模式。各模式的关系如图1.7所示。 1.3两级映像 数据库系统在三级模式之间提供了两级映像:模式/内模式映像、外模式/模式映像。正因为这两级映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性。 (1) 模式/内模式映像。存在于概念级和内部级之间,实现了概念模式和内模式之间的相互转换。 (2) 外模式/模式映像。存在于外部级和概念级之间,实现了外模式和概念模式之间的相互转换。 数据的独立性是指数据与程序独立,将数据的定义从程序中分离出去,由 DBMS 负责数据的存储,从而简化应用程序,大大减少应用程序编制的工作量。数据的独立性是由 DBMS 的二级映像功能来保证的。数据的独立性包括数据的物理独立性和数据的逻辑独立性。 (1) 数据的物理独立性。数据的物理独立性是指当数据库的内模式发生改变时,数据的逻辑结构不变。由于应用程序处理的只是数据的逻辑结构,这样物理独立性可以保证,当数据的物理结构改变时,应用程序不用改变。但是,为了保证应用程序能够正确执行,需要修改概念模式和内模式之间的映像。 (2) 数据的逻辑独立性。数据的逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构发生变化后,用户程序也可以不修改。但是,为了保证应用程序能够正确执行,需要修改外模式和概念模式之间的映像。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1016.html":{"url":"books/1016.html","title":"数据模型--如何设计","keywords":"","body":"数据模型--怎么设计 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1017.html":{"url":"books/1017.html","title":"概述","keywords":"","body":"概述 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1018.html":{"url":"books/1018.html","title":"定义","keywords":"","body":"定义 模型就是对现实世界特征的模拟和抽象,数据模型是对现实世界数据特征的抽象。对于具体的模型人们并不陌生,如航模飞机、地图和建筑设计沙盘等都是具体的模型。最常用的数据模型分为概念数据模型和基本数据模型（逻辑数据模型）[和物理模型]。 (1) 概念数据模型。概念数据模型也称信息模型,是按用户的观点对数据和信息建模,是现实世界到信息世界的第一层抽象,强调其语义表达功能,易于用户理解;是用户和数据库设计人员交流的语言,主要用于数据库设计。这类模型中最著名的是实体•联系模型,简称 E-R模型。 (2) 基本数据模型（逻辑数据模型）。它是按计算机系统的观点对数据建模,是现实世界数据特征的抽象,用于 DBMS 的实现。基本的数据模型有层次模型、网状模型、关系模型和面向对象模型 (ObjectOriented Model )。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1019.html":{"url":"books/1019.html","title":"三要素","keywords":"","body":"数据模型的基本要素 2.1数据结构 定义:用于描述数据的静态特性，它是所研究对象类型的集合。数据结构是所研究的对象类型的集合,是对系统静态特性的描述。 分类： Ø 数据描述对象 • 定义：用于描述数据的性质、内容和类型等相关的对象 • 指出对象所包含的项，并对项进行命名，指出项的数据类型和取值范围等。 Ø 数据关系描述对象 • 定义：是用于描述数据间关系信息的对象 • 指明各种不同对象类型之间的关系及关系的性质，并对这些关系进行命名。 2.2数据操作 定义:用于对数据动态特性的描述，它是对数据库中各种对象类型的实例允许执行的所有操作及相关操作规则的集合。数据操作是对数据库中各种对象(型)的实例(值)允许执行的操作的集合,包括操作及操作规则。例如操作有检索、插入、删除和修改,操作规则有优先级别等。数据操作是对系统动态特性的描述。 分类： Ø 查询 Ø 更新 • 更新操作又包括插入、删除和修改。 　　在数据模型中，要明确定义操作的各项属性，如操作符、操作规则以及实现操作的语言等。 2.3数据的约束条件 　　 数据的约束条件是一组完整性规则的集合。完整性规则是指既定的数据模型中数据及其关系所具有的制约性规则和依存性规则。这些规则是通过限定符合数据模型的数据库状态及其变化的方法来保证数据的正确性、有效性和相容性。数据的约束条件是一组完整性规则的集合。也就是说,对于具体的应用数据必须遵循特定的语义约束条件,以保证数据的正确、有效和相容。例如某单位人事管理中,要求在职的“男”职工的年龄必须大于18岁小于60,工程师的基本工资不能低于1500元,每个职工可担任一个工种,这些要求可以通过建立数据的约束条件来实现。 2.4三个要素的作用 　　数据结构是基础，它确定着数据模型的性质。 　　数据操作是关键，它确定着数据模型的动态特性。 　　约束条件主要起辅助作用。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1020.html":{"url":"books/1020.html","title":"数据模型的3种类型","keywords":"","body":"数据模型的3种类型 Ø 逻辑模型是对客观事物及其联系的数据描述，包括网状模型、层次模型、关系模型和面向对象模型等，它是从计算机系统观方面来进行建模，主要用于DBMS的实现。 Ø 概念模型又称信息模型，是从用户观方面来对数据和信息进行建模的结果，主要用于数据库的设计。 Ø 物理模型是对数据最底层的抽象，用于描述数据在计算机系统内部的表示方式和存取方法，其实现由DBMS完成。 　　数据模型的两大主要功能是用于描述数据及其关联。它包含三个基本要素，即数据结构、数据操作和数据的约束条件 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1021.html":{"url":"books/1021.html","title":"逻辑模型","keywords":"","body":"逻辑模型 四种主要的逻辑模型 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1022.html":{"url":"books/1022.html","title":"层次模型","keywords":"","body":"层次模型 3.1层次模型 　　以树状层次结构组织数据，它的数据结构是根树 　　特点： Ø有且仅有一个节点没有父节点，这个节点就是根树的根节点。 Ø除了根节点外，其他节点有且仅有一个父节点，但可能由0个或者多个子节点。 　　在层次模型中，具有相同父节点的子节点称为兄弟节点，没有子节点的节点称为叶节点。 　　在根树的层次结构中，每个节点代表一个实体型。但由于层次模型中的实体型是用记录型来表示，所以根树中的每个节点实际上是代表着一个记录型。由于每个记录型节点有且仅有一个父节点（根节点除外），所以只要每个节点指出它的父节点，就可以表示出层次模型的数据结构。如果要访问某一个记录型节点，则可以运用相关的根树遍历方法从根节点开始查找该节点，然后对其访问。 【例子】 一个学校包含多个学院，一个学院又包含多个系和研究所等。这样，学校、学院、系和研究所等实体非常自然地构成了现实世界中的层次关系。层次模型正是为了满足描述这种层次关系的需要而产生的。所以，它的表达方式自然、直观，但是其缺点也是明显。 下图所示为某学校按层次模型组织的数据示例。 某学校按层次模型组织的数据示例 ​ 层次模型缺点: • 处理效率低 Ø 这是因为层次模型的数据结构是一种根树结构，对任何节点的访问都必须从根节点开始。这使得对底层节点的访问效率变低，并且难以进行反向查询。 • 不易进行更新操作 Ø 更新操作包括插入、修改和删除等操作。对某一个树节点进行这种更新操作时，都有可能导致整棵根树大面积的变动。对大数据集来说，这可是一个沉重。 • 安全性不好 Ø 这主要体现在，当删除一个节点时，则它的子节点和孙子节点都将被删除。所以，必须慎用删除操作。 • 数据独立性较差 Ø 当用层次命令操作数据的时候，它要求用户了解数据的物理结构，并需要显式地说明存取途径。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1023.html":{"url":"books/1023.html","title":"网状模型","keywords":"","body":"网状模型 3.2网状模型 　　网状模型：每一个数据用一个节点表示，每个节点与其他节点都有联系，这样，数据库中的所有数据节点就构成了一个复杂的网络。图1.3所示为按网状模型组织的数据示例。 图1.3 按网状模型组织的数据示例 　　网状模型的数据结构是网状结构。网状模型反映着现实世界中实体间更为复杂的联系。由以下特点可以看出，节点间没有明确的从属关系，一个节点可以与其它多个节点有联系。 　　特点 Ø 允许存在一个以上的节点没有父节点。 Ø 节点可以有多余一个的父节点。 　　缺点： Ø 由于在使用网状模型时，用户必须熟悉数据的逻辑结构，所以结构的复杂性增加了用户查询和定位的难度。 Ø 不支持对于层次结构的表达等。 Ø 与层次模型类似，网状结构中的每个节点代表一个实体型，而这种实体型是用记录型来表示。与层次结构不同的是：在层次结构中有且仅有一个根节点，而在网状结构中则允许同时存在多个“根节点”；在层次结构中每个节点有且仅有一个父节点（根节点除外），而在网状结构中则允许一个节点同时有多个“父节点”。 Ø 这种结构上的差异，也导致了节点对应的记录型结构的变化。网状模型中节点间联系的实现必须由节点同时指出其父节点和子节点的方法来完成。而在层次模型中，每个节点只需指定其父节点即可（根节点除外）。也正是由于这种差异的存在，使得网状模型在性质和功能上发生了重要的改变。这主要体现在：网状模型比层次模型具有更大的灵活性和更强的数据建模能力。 【例子】 图1.8表示了学生A、B和课程C、D、E之间的一种选修联系的网状结构图。 　　对于小数据量而言，层次模型和网状模型的缺点可能不太明显，但是当作用于大数据量时，其缺点就显得非常突出。所以，这两种模型不适合用于当今以处理海量数据为特征的数据处理任务中。目前，它们基本上退出了市场，取而代之的是关系模型。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1024.html":{"url":"books/1024.html","title":"关系模型","keywords":"","body":"关系模型 3.3关系模型 3.3.1定义 　　关系模型：以二维表格（关系表）的形式组织数据库中的数据 　　关系模型是当今最为流行的一种数据模型。在关系模型中，实体间的联系是通过二维关系（简称关系）来定义，其数据结构就是二维关系。每个一种二维关系都可以用一张二维表来表示，表达直观、明了。所以，很多时候是把二维表和关系直接等同起来，简称为（二维）关系表。关系模型就是若干张关系表的集合。 　　例如，在学生成绩管理系统所涉及的学生、课程和成绩三个表中。学生表涉及的主要信息有学号、姓名、性别、出生时间、专业、总学分、备注。课程表涉及的主要信息有课程号、课程名、开课学期、学时和学分。成绩表涉及的主要信息有学号、课程号和成绩。表1.1、表1.2和表1.3分别描述了学生成绩管理系统中学生、课程和成绩这三个表的部分数据。 表1.1 学生表 学生、课程、成绩，三个对象 表可能是实体可能是多对多关系 表1.2 课程表 表1.3 成绩表 例如，表1.1中的“学号”可唯一标识每一个学生，表1.2中的“课程号”可唯一标识每一门课。表1.3中的“学号”和“课程号”可唯一标识每一个学生一门课程的成绩。 有时，一个表可能有多个码，比如表1.1中，姓名不允许重名，则“学号”、“姓名”均是学生信息表码。对于每一个关系表，通常可指定一个码为“主码”，在关系模式中，一般用下划线标出主码。 设表1.1的名字为XSB，关系模式可分别表示为XSB（学号，姓名，性别，出生时间，专业，总学分，备注）。 设表1.2的名字为KCB，关系模式可分别表示为KCB（课程号，课程名，开课学期，学时，学分）。 设表1.3的名字为CJB，关系模式可分别表示为CJB（学号，课程号，成绩，学分）。 3.3.2关系模型的术语 Ø 关系：一张二维表。 Ø 记录（或元组）：关系表中的一行。 Ø 字段（或属性）：关系表中的一列。 Ø 域：即字段的值域，也就是字段的取值范围。 Ø 数据项（或分量）：某一个记录中的一个字段值。 Ø 主关键字段（或主码）：简称主键，是关系表中一个或者多个字段的集合，这些记录的值能够唯一标识每一个记录。 Ø 关系模式：是对关系的一种抽象的描述，其描述格式为“关系名（字段1，字段2，…，字段n）”，其中“字段1”带下划线，表示该字段是主关键字段。 3.3.3关系模型的特点 • 具有严密的数学基础。关系代数、关系演算等都可以用于对关系模型进行定性或者定量的分析，探讨关系的分开和合并及其有关性质等。 • 概念单一化、表达直观，但又具有较强的数据表达和建模能力。一般来说，一个关系只表达一个主题，如果有多个主题在一起，则需要将它们分开，用多个关系来表示，这就是概念的单一化。 • 关系都已经规范化。即关系要满足一定的规范条件，这使得关系模型表现出特有的一些性质。 Ø 例如，在一个关系中数据项是最基本的数据单位，它不能再进行分解；同一个字段的字段值具有相同的数据类型；各字段的顺序是任意，记录的顺序也是任意的，等等。 • 在关系模型中，对数据的操作是集合操作，即操作的对象是记录的集合，操作所产生的结果也是记录的集合。这种操作不具有明显的方向性，不管如何操作，其难度都一样。而在层次模型和网状模型中，对数据的操作带有明显的方向性，在正反两个方向上操作的难度完全不一样。 3.3.4关系模型的缺点 Ø 对复杂问题的建模能力差。在对复杂问题建模时一般都会呈现出错综复杂的关系，而关系模型仅限于用二维关系来表示这些复杂关系，无法用递归和嵌套的方式来描述（因为它不允许嵌套记录和嵌套关系的存在）。所以，在许多时候关系模型显得力不从心。 Ø 对象语义的表达能力比较差。现实世界中，对象之间的关系往往不仅限于量的关系，而且还可能体现语义之间的联系，蕴涵着特定的内涵。但关系模型为了规范化这些关系，可能会强行拆开这种语义联系，造成不自然的分解，从而使得在查询等操作时出现语义不合理的结果。 Ø 可扩充性差。关系模式只支持记录的集合这一种数据结构，并且数据项不可再分，无法形成嵌套记录和嵌套关系，所以它无法扩充成层次模型或网状模型。且它不支持抽象数据类型，不能对多种类型数据对象进行管理。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1025.html":{"url":"books/1025.html","title":"面向对象模型","keywords":"","body":"面向对象模型 3.4面向对象模型 　　面向对象方法(Object-Oriented Paradigm，简称OO)基本出发点就是按照人类认识世界的方法和思维方式来分析和解决问题。 　　面向对象模型是由面向对象方法进行建模和表示而形成的数据模型。 　　面向对象模型的相关理论和方法还不够成熟，主要是处于理论研究和实验阶段。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1026.html":{"url":"books/1026.html","title":"概念模型","keywords":"","body":"概念模型 ​ 概念模型是对信息世界建模,所以概念模型能够方便、准确地表示信息世界中的常用概念。 　　从数据模型的建模方法来看，一般是先将现实世界中的问题建模为信息世界中的概念模型，然后将信息世界中的概念模型转化为机器世界中的逻辑模型。 　　当确认概念模型已经能够充分表达原问题（现实世界中）的时候，再将这种概念模型转化为数据库系统中某一个既定DBMS支持的数据模型，形成机器世界中的逻辑模型。 　　从现实世界到机器世界的转换过程可以用图1.9来表示。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1030.html":{"url":"books/1030.html","title":"物理模型","keywords":"","body":"物理模型 数据的物理模型指数据的存储结构，如对数据库物理文件、索引文件的组织方式、文件的存取路径，内存的管理等。物理模型对用户是不可见的，它不仅与数据库管理系统有关，还与操作系统甚至硬件有关。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1033.html":{"url":"books/1033.html","title":"定义","keywords":"","body":"概念 ​ 关系数据库（Relation database）是以关系模型为基础的数据库，它是利用关系来描述实体及实体之间的联系。简单地说，一个关系数据库是若干个关系的集合。一个关系可表示为一张二维表（也称数据表），一个关系数据库也可以理解为若干张二维表的集合。 一张数据表是由一系列的记录（行）组成，每一条记录由若干个数据项组成。数据项也是前面讲到的字段值、属性值，是关系数据库中最小的数据单位，不能再分解。 每一张数据表都有自己的表名。在同一个数据库中，表名唯一。当要访问数据库中的某一个数据项时，先通过表名找到相应的数据表，然后检索到该数据项所在的记录，最后通过记录访问到该数据项。 “元组”、“分量”等概念多用于描述关系模型，可理解为理论范畴中的概念；而“记录”、“数据项”则分别是“元组”、“分量”在关系数据库中的映象，理解为它们的实例化对象。它们基本上是对应的。 这种对应关系说明如下表所示（但这种对应关系不是严格的，在使用中要视上下文而定）。 关系模型 关系数据库 关系 数据表 元组 记录 属性 字段 分量 数据项 域 字段值域 主码 主关键字段（主键） 外码 外关键字段（外键） 关系模式 字段集 3元关系R的一个二维表 学号（D1） 姓名（D2） 英语（D3） 201301 刘洋 70 201302 李思思 90 数据库理论中的一些概念 Ø 关系：一个关系等同于一张二维表，是有限元组的集合；一个数据库可以视为若干关系的集合 Ø 元组：二维表中的一行对应一个元组，也称为记录。 由表2.2所示，“201301”，““刘洋”和“70”构成的行就是元组(201301，刘洋, 70)。 Ø 属性：二维表中的每一列都称为属性或字段。 Ø 域：即属性的值域，也就是属性的取值范围。 由表2.2所示，“学号”这个属性的值域为{201301, 201302}。 Ø 分量：一个元组中的一个属性值，也常称为数据项。 由表2.2所示，“刘洋”、“70”等都是数据项。数据项不能再分了，它是关系数据库中最小的数据单位。 Ø 候选码和主码：如果二维表中存在一个属性或若干属性组合的值能够唯一标识表中的每一个元组，则该属性或属性组合就称为候选码，简称码；如果一个表存在候选码，且从中选择一个候选码用于唯一标识每一个元组，则该候选码称为主码（Primary key）。主码也常称为主健（主关键字段）。 Ø 主属性和非主属性：包含在任何候选码中的属性都称为主属性，不包含在任何候选码中的属性称为非主属性。 关系数据库的特点 ​ 关系数据库的主要特点和优点包括： 具有较小的数据冗余度，支持创建数据表间的关联，支持较为复杂的数据结构。 应用程序脱离了数据的逻辑结构和物理存储结构，数据和程序之间的独立性高。 实现了数据的高度共享，为多用户的数据访问提供了可能。 提供了各种相应的控制功能，有效保证数据存储的安全性、完整性和并发性等，为多用户的数据访问提供了保证。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1032.html":{"url":"books/1032.html","title":"理论基础","keywords":"","body":"理论基础 关系模型 关系代数 规范化理论 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1035.html":{"url":"books/1035.html","title":"关系模型基本要素--怎么组成","keywords":"","body":"关系模型基本要素--怎么组成 关系模型的基本要素：关系模型的数据结构、关系操作和关系的完整性约束三部分。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1036.html":{"url":"books/1036.html","title":"关系--关系模型的数据结构","keywords":"","body":"关系模型的数据结构——关系 关系定义 令$D = D_1×D_2×…×D_n = {(d_1, d_2,…, d_n) | d_i∈D_n , i = 1,2,…,n}$，即D为D1, D2, …, Dn的笛卡儿积，则D的任何非空子集R都称为D1, D2, …, Dn上的n元关系，其中Di为有限的属性值域，i = 1,2,…,n。 一个n元关系R通常记为$R(D_1, D_2, …, D_n)$，R中的任一元素$(d_1, d_2,…, d_n)$称为n元组，简称元组（Tuple）。元组中的每个值di称为分量。n称为关系的度或元。当n = 1时，R称为单元关系；当n = 2时，R称为二元关系。 注意，一个关系实际上就是若干元组的集合。一个关系必须是有限元组的集合，无限集合对数据库技术来说是无意义的。 笛卡儿积可以用二维表直观地表示。 【例子】 假设笛卡儿积D = D1×D2×D3，D1为学号的集合， D1={201301, 201302}，D2为姓名的集合， D2={李思思, 刘洋}，D3为英语成绩（简称“英语”）的集合， D3={90, 85, 70}。 D = {201301, 201302}×{李思思, 刘洋}×{90, 85, 70} = { (201301, 李思思, 90), (201301, 李思思, 85), (201301, 李思思, 70), (201301, 刘洋, 90), (201301, 刘洋, 85), (201301, 刘洋, 70), 　　 (201302, 李思思, 90), (201302, 李思思, 85), (201302, 李思思, 70), 　　 (201302, 刘洋, 90), (201302, 刘洋, 85), (201302, 刘洋, 70)}。 笛卡儿积D的二维表 学号（D1） 姓名（D2） 英语（D3） 201301 李思思 90 201301 李思思 85 201301 李思思 70 201301 刘洋 90 201301 刘洋 85 201301 刘洋 70 201302 李思思 90 201302 李思思 85 201302 李思思 70 201302 刘洋 90 201302 刘洋 85 201302 刘洋 70 由上面定义，D为一个笛卡儿积，D的任意子集都是三元关系。 令R = {(201301, 刘洋, 70), (201302, 李思思, 90)}，R 为D的一个子集，所以R 为3元关系。 这个关系记作R(D1, D2, D3)，其对应二维表示如表所示。 3元关系R的一个二维表 学号（D1） 姓名（D2） 英语（D3） 201301 刘洋 70 201302 李思思 90 笛卡儿积D本身也是一种关系，但这种关系由于过于泛化而可能会导致语义上的矛盾，从而失去实际意义。一般来说，只有部分关系有意义，而不是全部。 【例子】 元组(201301, 刘洋, 90)和元组(201301, 刘洋, 85)就是一对矛盾的元组，因为学号“201301”、姓名为“刘洋”的学生的英语成绩不可能同时取90分和85分这两个值。 关系的性质 Ø 列是同质的，即每一列中的分量是同一类型的数据，它们都是来自同一个域。 Ø 每一列为一个属性，不允许存在相同属性名的情况。 Ø 列（行）的顺序是任意的，列（行）的次序可以任意交换。 Ø 不允许存在两个相同的元组。 Ø 每一个分量都是不可再分的，即不允许表中套表。 关系模式 定义 假设一个n元关系R的属性分别为A1, A2, …, An，令R(A1, A2, …, An)表示关系R的描述，称为关系模式。 Ø 关系模式是由属性构成，与属性值无关。为了体现关系模式中的主码，对构成主码的属性添加下划线。 【例子】在关系模式R(A, B, C, D, E)中，属性A和B的组合是该关系模式的主码。 Ø 关系模式是描述关系的“型”，即凡是具有相同属性的关系都属于相同的“型”，即它们都属于同一个关系模式。 Ø 一个关系模式可以视为一类具有相同类型的关系集合，属于同一个关系模式的关系都拥有相同的属性（但属性值却不一定相同）。 Ø 一个特定的关系是其对应关系模式的“值”，或者说关系是关系模式这个集合中在某一时刻的一个“元素”。 关系和关系模式的区别和联系 • 关系和关系模式之间的联系就好像是数据类型和数据之间的联系。 • 关系模式和关系是有区别的，即前者是后者的抽象，后者是前者的特定实例 • 关系模式是相对稳定的，数据在更新，关系是随时间变化的。但在运用中常常将它们统称为关系，读者可根据上下文来区分。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1037.html":{"url":"books/1037.html","title":"关系操作","keywords":"","body":"关系操作 关系操作的分类：查询操作、c 查询操作 查询操作是最常用和最主要的操作，其包括： 选择：从关系中检索出满足既定条件的所有元组的集合，这种操作就称为选择。其中，选择的条件是以逻辑表达式给出的，使表示式的值为真的元组被选取。从二维表的结构上看，选择是一种对行的操作。（最常用） 投影：从关系中选出若干个指定的属性来组成新的关系，这种操作就称为投影。从二维表的结构上看，选择是一种对列的抽取操作。 连接：从两个关系中抽出满足既定条件的元组，并将它们“首尾相接”地拼接在一起，从而形成一个新的关系，这种操作称为连接。 除：一种行列同时参加的运算。 以下三个选择操作的共同特点是，参加运算的两个关系必须有相同的属性个数，且相应属性的取值分别来自同一个域（属性名可以不同）： 并：将两个关系中的元组合并到一起（纵向），从而形成一个新的关系，这种操作称为并。 交：将两个关系中的共同元组组成一个新的关系，这种操作称为交。 差：将第一个关系中的元组减去第二个关系中的元组，从而也产生了新的关系，这种操作称为差。 查询操作 更新操作种类：（最常用） 插入：把一个关系（元组的集合）插入到已有的关系中，形成新的关系。 删除：从一个关系中删除满足既定条件的所有元组，剩下的元组构成新的关系。 修改：利用给定的值更改关系中满足既定条件的所有元组的对应分量值，更改后得到新的关系。 关系操作的特点： 针对集合进行，即操作的对象是元组的集合，操作后所得到的结果也是元组的集合。 非关系模型（网状模型和层次模型）的操作对象是一个元组。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1038.html":{"url":"books/1038.html","title":"关系的完整性约束","keywords":"","body":"关系的完整性约束 关系是关系模型的数据结构。关系需要满足一些基本要求——关系的完整性约束。 完整性约束包括：实体完整性约束、参照完整性约束、用户定义的完整性约束。 实体完整性 每一个关系中的主码属性的值不能为空（NULL），能够唯一标识对应的元组。 原因：主码设置的目的是用于区分关系中的元组，以将各个元组区别开来。如果主码中的属性值可以为空，那么在关系中将存在一些不确定的元组，这些元组将不知道是否能够与别的元组有区别（因为空值被系统理解为“不知道”或“无意义”的值），这在关系模型中是不允许的。各个元组在主码上的取值不允许相等，否则就不满足实体完整性约束。 实体完整性是关系模型必须满足的完整性约束条件。 【例2.1】考虑如 student关系表所示的学生关系student(学号, 姓名, 性别, 专业号)和course关系表所示的课程关系course(课程号, 课程名, 学分)。假设学生关系的主码为“学号”，课程关系的主码为“课程号”，那么学生关系的“学号”以及课程关系的“课程号”的取值就不能为空，而且取值不能重复（能唯一标识每一行），否则就不满足实体完整性。 student关系表 学号 姓名 性别 专业号 201301 刘洋 男 z1 201302 李思思 女 z2 201303 陈永江 男 z2 201304 王大河 男 z3 201305 吕文星 男 z3 201306 李鑫 女 NULL course关系表 课程号 课程名 学分 13986 数据库原理 4 13987 操作系统 4 13988 数据结构 6 13989 软件工程 3 参照完整性 参照完整性与外码密切相关，这里先介绍外码的概念。 对于关系R和S，假设F是关系R的一个属性或一组属性，但F不是R的码，K是关系S的主码，且F与K相对应（或相同），则F称为R的外码（Foreign key），R和S分别称为参照关系（Referencing relation）和被参照关系（Referenced relation），如图所示。 参照关系 • F与K是相同的属性或属性集，它们的取值范围相同。 • 关系模型的参照完整性约束：外码F中的每个属性值等于主码K的某一个属性值或F的每个属性值均为空值。 • 如果要在关系R中插入一个元组，则该元组在属性F上的取值等于关系S中某一个元组在主码K上的取值或全置为空值，否则不能插入该元组。当关系S为空时，不能向关系R中插入元组；当要删除关系S中的一些元组时，必须先删除关系R中与这些元组相关联的元组。 • 参照完整性也是关系模式必须满足的完整性约束条件。 选课关系SC(学生编号, 课程编号, 成绩)，如表2.5所示。可见属性组{学生编号，课程编号}为该关系的主码。 表2.5 SC关系表 学生编号 课程编号 成绩 201301 13989 78 201301 13987 85 201302 13989 89 201303 13986 92 　属性“学生编号”是选课关系的外码，它与关系“student（学号, 姓名, 性别, 专业号）”的主码“学号”相对应，选课关系为参照关系，学生关系为被参照关系，“课程编号”同理。 ​ 外码“学生编号”和“课程编号”共同组成了该关系的主码，这两个属性的取值不能为空，只能为相应被参照关系中相应列中的取值。 表2.5中“学生编号”列的属性值“201301”必须等于表2.3中“学号”列中的某一个属性值；表2.5中的“课程编号”列的属性值“13989”必须等于表2.4中“课程号”列中的某一个属性值。 表2.3 student关系表 学号 姓名 性别 专业号 201301 刘洋 男 z1 201302 李思思 女 z2 201303 陈永江 男 z2 201304 王大河 男 z3 201305 吕文星 男 z3 201306 李鑫 女 NULL 表2.4 course关系表 课程号 课程名 学分 13986 数据库原理 4 13987 操作系统 4 13988 数据结构 6 13989 软件工程 3 ​ 表2.6所示的专业关系major（专业编号, 专业名），该关系的主码是“专业编号”，且表2.3所示关系“学生”中的“专业号”与该关系中的“专业编号”相对应，即“专业号”是学生关系student的外码。在这种情况下，由于学生关系student中的“专业号”不是该关系的主码，因而“专业号”列的属性值可以取空值。 表2.3中学生“李鑫”所对应的“专业号”为空值，这表明尚未给该学生分配专业。 表2.6 major关系表 专业编号 专业名 K0301 201301 K0302 201302 K0303 201301 K0304 201303 用户定义的完整性 用户定义的完整性是指由用户定义的、针对某一具体应用需求制定的约束条件，多用于满足数据的一些语义要求。 在表2.5所示的关系SC中，经常定义这样的约束：成绩的取值必须在0～100之间；又如，某些属性值不能为空或取值必须唯一等。 用户定义完整性约束可以有效减少应用程序的负担，关系数据库管理系统都提供定义和检验这类完整性的机制和方法。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1039.html":{"url":"books/1039.html","title":"关系代数--操纵语言的数学表达","keywords":"","body":"关系代数--操纵语言的数学表达 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1040.html":{"url":"books/1040.html","title":"基本集合运算","keywords":"","body":"基本集合运算 基本集合运算是指集合的并、交、差和笛卡儿积运算，这些运算都是二元运算。我们约定：本节中R和S都默认是n元关系，且对应属性取自同一个值域。以下介绍基于关系的基本集合运算。 并∪ n元关系R和S的并是一种新的n元关系，这个新的关系是由R的元组或S的元组组成，记为R∪S，即$R∪S = {x| x∈R∨x ∈S}$ 交∩ n元关系R和S的交是一种新的n元关系，这个新的关系是由R和S的共同元组组成，也就是说，由既属于R的元组又属于S的元组组成，记为R∩S，即$R∩S = {x| x ∈ R ∧ x ∈S }$ 差－ n元关系R和S的差是一种新的n元关系，这个新的关系是由属于R的元组但不属于S的元组组成，记为R－S，即$R-S = {x | x ∈ R∧x∈S}$ 笛卡儿积 设R和S分别是n元关系和m元关系，则R和S的笛卡儿积是一种(n + m)元关系，该关系是由R的每一个元组分别与S每一个元组进行“首尾并接”所得到的元组的集合，记为R×S，即$R×S = {x_r x_s| x_r ∈ R∧ x_s ∈ S}$ $x_rx_s$是表示由元组和$x_r$元组$x_r$并接而得到的新元组。 关系R和S的元组个数分别为$k_r$和$k_s$，则R×S的元组个数为$k_r×k_s$。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1041.html":{"url":"books/1041.html","title":"关系运算","keywords":"","body":"关系运算 关系一些特殊的运算，主要包括选择（σ）、投影（π）、连接（⋈ ）、除（/）等。 先约定一种表示方法：设x为某一个关系R的一个元组，L为R的关系模式的一个子集（即属性子集），则令x(L)表示由元组x在属性子集L上的所有分量构成的新元组。 对于关系R(A,B,C,D)，令x = (a , b ,c , d)，则x({A,B,C}) = (a , b , c)，x({C,D}) = (c , d)，x({B}) = (b)，等。 选择σ 从关系中筛选出满足既定条件的元组，这些元组组成了一个新的关系，这个操作过程称为选择。 选择的操作符用σ表示，选择条件则用逻辑公式来表示，用R表示逻辑公式。对关系R的选择运算就可以表示为$σ\\tau(R)$，即$σ\\tau(R) = {x | x∈R∧\\tau(x) = true}$ 　　　　“t(x) = true”表示元组x满足条件公式t。对于选择运算，关键是设置选择条件t。 　　　　在数据查询中，条件公式t通常是由、≤、≥、=、between、∧、∨等连接符号构成的条件表达式或逻辑表达式。 表2.3所示的学生关系student。令选择条件t = (性别=‘男’∧专业号=‘z3’)，则选择运算$σ_\\tau(student)$表示查找那些专业号为“z3”的男同学，结果如表2.7所示。 表2.3 student关系表 学号 姓名 性别 专业号 201301 刘洋 男 z1 201302 李思思 女 z2 201303 陈永江 男 z2 201304 王大河 男 z3 201305 吕文星 男 z3 201306 李鑫 女 NULL 表2.7 执行选择$σ_\\tau(student)$后得到的关系 学号 姓名 性别 专业号 201304 王大河 男 z3 201305 吕文星 男 z3 选择是选择行，选择符合条件的行，列还是所有的列 投影π 投影是指从关系中选出若干个指定的属性来组成新的关系。令投影的操作符为π，L为指定的属性子集，则关系R在属性子集L上的投影就可以表示为πL(R)，即 $π_L(R) = {x(L) | x ∈ R}$ x(L)表示由元组x在属性集L*上的取值构成的新元组。 投影还有一种表示方法就是在投影运算表达式$π_L(R)$中用指定的属性在关系R中的序号来代替L中的属性名。 投影就是从关系表中按指定的属性抽取相应的列，这些列组成一个新的关系。 注意，投影运算是对列进行筛选，而选择运算则对行进行筛选。 对于表2.3所示的学生关系student，令L = {姓名，性别}，则学生关系在L上的投影： 对于上述的投影π{姓名，性别} (student)也可以表示为π{2，3}(student) ​ πL(student) = {x(L) | x∈ R} ​ = {x({姓名，性别}) | x∈ R} ​ = {(刘洋,男), (李思思,女), (陈永江,男), (王大河,男), (吕文星,男), (李鑫,女)} 表2.8 关系student投影后 姓名 性别 刘洋 男 李思思 女 陈永江 男 王大河 男 吕文星 男 李鑫 女 连接 $\\Join $ 连接运算是二元运算，即涉及到两个关系的运算。假设参与运算的两个关系是R和S，则连接运算的结果是R和S笛卡儿积中满足属性间既定条件的元组的集合，即它是R和S笛卡儿积的一个子集。连接运算常用的主要有两种：等值连接和自然连接。 1）等值连接 对于关系R和S，假设F和M分别是关系模式R和S的属性子集，如果按照F和M进行连接，则R和S的等值连接表示为：$R \\Join _{F =M }S = {x_r x_s | x_r \\in R∧ x_s \\in S ∧ x_r (F)= x_s (M)}$ $x_r x_s$表示由元组$x_r $和$x_s$连接起来而构成的新元组。等值连接$R \\Join S$是R和S笛卡儿积的一个子集，子集中的元组在F和M上的取值相等。 2）自然连接 自然连接是一种特殊的等值连接，它是在等值连接的基础上加上两个条件： （1）参与比较的属性子集F 和M 必须是相同的，即F=M； （2）形成的新关系中不允许存在重复的属性，如果有则去掉。R和S的自然连接可以表示为：：$R \\Join _{F }S = {x_r x_s | x_r \\in R∧ x_s \\in S ∧ x_r (F)= x_s (F)}$ F是关系R和S都包含的属性（组）。 表2.9和表2.10所示的两个关系，分别表示学生的基本信息和学生的考试成绩。 表2.9 关系stu_info 姓名 年龄 籍贯 刘洋 19 北京 王晓珂 22 上海 王伟志 20 上海 王伟志 21 天津 表2.10 关系grade 姓名 高数 英语 岳志强 22 66 王晓珂 98 89 王伟志 22 68 王强 68 82 等值连接$stu_info⋈ {年龄=高数}grade$和$stu_info⋈ {姓名=姓名}grade$以及自然连接$stu_info ⋈ _{姓名}grade$的结果分别见表2.11、表2.12和表2.13所示。 从这三个结果的对比中读者不难比较这几种连接的区别。 等值连接$stu_info⋈ _{年龄=高数}grade$ 姓名 年龄 籍贯 姓名 高数 英语 王晓珂 22 上海 岳志强 22 66 王晓珂 22 上海 王伟志 22 68 等值连接$stu_info⋈ _{姓名=姓名}grade$ stu_info.姓名 年龄 籍贯 grade.姓名 高数 英语 王晓珂 22 上海 王晓珂 98 89 王伟志 20 上海 王伟志 22 68 王伟志 21 天津 王伟志 22 68 自然连接$stu_info ⋈ _{姓名}grade$ 姓名 年龄 籍贯 高数 英语 王晓珂 22 上海 98 89 王伟志 20 上海 22 68 王伟志 21 天津 22 68 除/ 对于关系模式$R(L_R)$和$S(L_S)$，约定： ​ $L_R$ --- R的属性集 ​ $L_S$ --- S的属性集 ​ L = $L_R$ ∩$L_S$ (即L表示关系R和关系S的公共属性) ​ $Lx = {t(L) | t∈R∧t(L_R-L)=x}$ (其中，$x∈π{L_R -L（R）}$ ，$L_x$称为x在R中关于L的像集) ​ R和S的除运算产生一个新关系R/S： ​ 该新关系由投影 $π_{L_R -L}（R）$中的某些元组组成，这些元组在R中关于L的像集包含S在L上的投影πL(S)。即：$R/S = {t(L_R-L) | t \\in R∧\\pi _L(S) \\subseteq L_x∧x = t(L_R-L)}$ 相同部分所在行中 被除数的 除去相同部分 表a的前两行 去掉相同的 CD列 ​ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1061.html":{"url":"books/1061.html","title":"规范化理论","keywords":"","body":"规范化理论 * [函数依赖--表内与表间的关系](books/1042.md) * [关系模式的范式--关系模式的规范化](books/1043.md) * [第一范式(1NF)](books/1044.md) * [第二范式(2NF)](books/1045.md) * [第三范式(3NF)](books/1046.md) * [BC范式(BCNF)](books/1047.md) * [分解与规范化](books/1048.md) 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1042.html":{"url":"books/1042.html","title":"函数依赖--表内与表间的关系","keywords":"","body":"函数依赖--表内与表间的关系 函数依赖的概念 定义: 设R(U)是属性集U上的一个关系模式，$A, B \\subseteq U$，对于R(U)的任意一个可能的关系r，若关系r的两个元组$x_1, x_2$满足$x_1(A) = x_2(A)$，则必有$x_1(B) = x_2(B)$，那么A函数决定B，或称B函数依赖于A，记为A→B，A中的每个属性都称为决定因素（Determinant），其中x1(A)表示元组x1在属性集A上的取值。如果A→B且B→A，则记为$A \\leftrightarrow B$；如果A→B不成立，则记为 $A \\rightarrow \\mkern-16.5mu/ B$。 函数依赖不是指关系模式R(U)的某一个或某一些关系满足的约束条件，而是指关系模式R(U)的所有关系均需要满足的约束条件。 【例】表2.3所示的学生关系模式student（学号, 姓名, 性别, 专业号）。学号是不允许重复的，如果学号相同的两个学生元组在其他属性上的取值肯定相同，可以推出{学号} →{姓名}, {学号} → {性别}, {学号} → {专业号}。 属性间的这种函数依赖关系跟语义有关，它属于语义范畴的概念。 【例】 如果不允许出现重名的学生元组，则可以有{姓名} →{学号}，进而{学号} ↔ {姓名}。 如果属性集是由单个属性构成，标志集合的大括号“{”和“}”可以省略， 如“{学号} →{姓名}”可以写成“学号→ 姓名”。 注意，在实际数据库开发中，可以从用户提供的需求说明中或是从基本常识中获取函数依赖关系， 例如上述“学号→ 姓名”就是一个基本常识。 ​ 定义: 设R(U)是属性集U上的一个关系模式，A,B ⊆ U。若A→B是一个函数依赖，如果$B \\subset A$，则称A→B为一个平凡函数依赖；如果B⊄A，则称A→B为一个非平凡函数依赖。 对于任意B⊆A，显然有A→B，它是一种平凡函数依赖。 【例子】“{学号, 姓名} → 姓名”是一种平凡函数依赖。由于平凡函数依赖没有实际意义，一般不予以讨论，在默认情况下提到的函数依赖均指非平凡函数依赖。 定义2.5 设R(U)是属性集U上的一个关系模式，A, B ⊆ U。若A→B是一个函数依赖，并且对于任意C $\\subset$ A且C非空，均有C$ \\rightarrow \\mkern-16.5mu/ $ B，则称A→B是一个完全函数依赖（Full functional dependency），即B完全函数依赖于A，记为AB；$\\stackrel{f}{\\rightarrow}$ 否则称A→B是一个部分函数依赖（Partial functional dependency），即B部分函数依赖于A，记为A$\\stackrel{p}{\\rightarrow}$ B。 【例2.3】表2.5所示的选课关系模式SC（学生编号，课程编号，成绩），{学生编号, 课程编号} $\\stackrel{f}{\\rightarrow}$成绩，因为学生编号 $\\rightarrow \\mkern-16.5mu/ $ 成绩且课程编号 $\\rightarrow \\mkern-16.5mu/ $ 成绩。又如，表2.3所示学生关系模式student（学号, 姓名, 性别, 专业号），{学号, 姓名} $\\stackrel{p}{\\rightarrow}$ 性别，确实有{学号, 姓名} → 性别，但学号→性别。 对于函数依赖A→B，如果A只包含一个属性，则必有A $\\stackrel{f}{\\rightarrow}$ B中，因为这时的A不存在非空真子集。 定义2.6 设R(U)是属性集U上的一个关系模式，A, B, C ⊆U。若A→B (B$ ⊆\\mkern-16.5mu/$A, B $ \\rightarrow \\mkern-16.5mu/ $ A)，且B→C成立，则称C传递函数依赖于A，记为A $\\stackrel{t}{\\rightarrow}$C。 注意，此处加上条件B $ \\rightarrow \\mkern-16.5mu/ $ A，是因为如果B→A，则实际上变为A↔B，即A→C，而不是A $\\stackrel{t}{\\rightarrow}$ C。 【例2.4】 对于关系模式—分班(学号, 班级号, 班长)，容易知道学号→ 班级号，班级号→ 班长，又因为班级号$ \\rightarrow \\mkern-16.5mu/ $ 学号，于是学号 班$\\stackrel{t}{\\rightarrow}$长。 候选码和主码 定义2.7 在关系模式R(U)中，假设A ⊆ U，如果A $\\stackrel{f}{\\rightarrow}$U，则A称为关系模式R(U)的一个候选码；候选码可能有多个，从候选码中选择一个用于唯一标识关系中的每一个元组，则该候选码称为主码（Primary key）。 含在任何候选码中的属性称为主属性（Prime attribute），不包含在任何码中的属性称为非主属性(Nonprime attribute)。通常将主码和候选码都简称为码。最简单的情况，单个属性构成码；最极端的情况，一个关系模式的所有属性构成码，称为全码（All key）。 对于候选码和主码，需要说明几点： 为正确理解候选码A，应该紧紧抓住其以下两个特性： (1)A可以函数决定U，即A→U。(2) A具有极小性，即A的任何真子集都不可能函数决定U。 候选码可能有多个。如果有多个候选码，则它们的地位是平等的，任何一个都可以被设置为主码。在应用当中，一般是根据实际需要来将某一个候选码设置为主码。 定理2.1 在关系模式R(U)中，对任意A, B ⊆U且A ∪ B = U，如果A $\\stackrel{f}{\\rightarrow}$ B，则有A $\\stackrel{f}{\\rightarrow}$ U，从而A是关系模式R(U)的一个候选码。 【例2.5】 考虑如表2.16所示的学生成绩关系模式，其中U = {学号, 姓名，系别，成绩}。对于属性“学号”，容易验证：学号 $\\stackrel{f}{\\rightarrow}$ {姓名，系别，成绩}，而{学号}∪{姓名，系别，成绩} = U。根据定理2.1，“学号”是学生成绩关系模式的一个候选码。 表2.16 学生成绩关系 学号 姓名 系别 成绩 1 赵高 计算机系 60 2 赵高 计算机系 71 3 王永志 计算机系 87 4 蒙恬 电子商务系 87 5 蒙恬 电子商务系 54 6 李思思 电子商务系 92 函数依赖的性质（Armstrong公理系统） 1974年Armstrong首次提出了这样的一套推理规则，由此构成的系统就是著名的Armstrong公理系统。 在关系模式R(U)中，假设A, B, C, D为U的任意子集。在Armstrong公理系统中，基于函数依赖集F的推理规则可以归结为以下3条： 自反律：若C ⊆ B，则B→C为F所蕴含（平凡函数依赖）。 增广律：若B → C为F所蕴含，则B∪D→C∪D为F所蕴含。 传递律：若B→C且C→D为F所蕴含，则B→D为F所蕴含。 基于上述的推理规则，进一步得到下列的推理规则： 自合规则：B→B。 合并规则：若B→C且B→D，则B→C∪D。 分解规则：若B→C∪D，则B→C且B→D。 符合规则：若A→B且C→D，则A∪C→B∪D。 伪传递规则：由B→C，A∪C→D，有A∪B→D。 定理2.2 在关系模式R(U)中，B及B1, B2,…, Bn是U的子集，则B→B1∪B2∪…∪Bn成立的充分必要条件是B→Bi成立，其中i = 1,2,…,n。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1043.html":{"url":"books/1043.html","title":"关系模式的范式--关系模式的规范化","keywords":"","body":"关系模式的范式--关系模式的标准 范式一共分为六个等级，从低到高依次是第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、BC范式（BCNF）、第四范式（4NF）和第五范式（5NF）。 高等级范式是在低等级范式的基础上增加一些约束条件而形成的，等级越高，范式的约束条件就越多，要求就越严格。各种范式之间的包含关系可以描述如下： ​ 5NF ⊆ 4NF ⊆ BCNF ⊆ 3NF ⊆ 2NF ⊆ 1NF 通过模式分解，可以将一个低级别的范式转化为若干个高一级的范式，而这种转化过程称为规范化。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1044.html":{"url":"books/1044.html","title":"第一范式(1NF)","keywords":"","body":"第一范式(1NF) 定义2.8 设R(U)是一个关系模式，U是关系R的属性集，若U中的每一个属性a的值域只包含原子项，即不可分割的数据项，则称R(U)属于第一范式，记为R(U)∈1NF。 是一个m*n的表且无合并单元格 【例子】表2.17所示。该数据表所对应的关系模式不属于第一范式，因为其中每个元组在“学生人数”属性上的属性值都不是原子项，它们都可以再分，实际上它们都是由两个原子项复合而成。为将其转化为第一范式，需要将复合项（非原子项）分解为原子项即可，结果如表2.18所示。 [2.6]假设有一个研究生信息管理系统，该系统涉及的信息主要包括导师信息、研究生信息以及所选课程信息（supervisor, student, course）等。设计了如下的一个关系模式： SSC(学号, 姓名, 系别, 导师工号, 导师姓名, 导师职称, 课程名称, 课程成绩) 。 根据常识可以知道： • 一位研究生只有一位导师（不含副导师），但一位导师可以指导多位研究生； • 一位研究生可以选修多门课程，一门课程也可以被多位研究生选修； • 一位研究生选修一门课程后有且仅有一个成绩； • 不同的课程，课程名是不相同的，即课程名是唯一。 基于以上语义信息可以知道： • 学号→{姓名, 系别} • 学号→导师工号 • 导师工号→{导师姓名, 导师职称} • {学号, 课程名称}→课程成绩 根据Armstrong公理及定理2.2可以推知： {学号, 课程名称}→{学号, 姓名, 系别, 导师工号, 导师姓名, 导师职称, 课程名称, 课程成绩} 且可以进一步推知： {学号, 课程名称} f→ {学号, 姓名, 系别, 导师工号, 导师姓名, 导师职称, 课程名称, 课程成绩} 根据定义2.7，{学号, 课程名称}是关系模式SSC的候选码，实际上是唯一的候选码，所以故只能选择它为模式的主码。 关系模式SSC存在的缺点： • 数据冗余 ​ 关系中每个元组既包含研究生信息，也包含导师信息以及所选课程的信息。一位导师可指导多名研究生，每个研究生对应的元组都包含同一个导师的相同信息。一位导师带有多少名研究生就有多少条重复的导师信息。造成了数据冗余，如果数据量很大，就会浪费大量的存储空间，为这些数据的维护付出巨大的代价。 • 插入异常 ​ 假设某个老师刚刚被聘为研究生导师，但还没有招收学生（这种情况经常出现），这时也就没有他的研究生信息和研究生选修课程的信息，意味着“学号”和“课程名称”等属性的属性值为空（null）。如果这时在关系SSC中插入该导师的信息，则会产生异常。因为属性“学号”和“课程名称”是主码，其取值不能为空。这种异常就是插入异常。插入异常的存在使得添加导师信息的操作无法完成。 • 删除异常 ​ 假设某个导师刚招收了两名研究生，但过了一个学期以后，这两个研究生都因出国而注销学籍了。注销时，将这两个研究生对应的元组从关系SSC中删除（全部删除）。由于删除操作是以元组为单位进行的，所以导师信息也将全部被删除，以后就无法使用该导师的信息了，称为删除异常。 ​ 关系模式SSC还容易产生数据不一致等其他的一些问题。仅满足第一范式的关系模式确实还存在许多问题。人们在第一范式的基础上增加一些约束条件，从而得到第二范式。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1045.html":{"url":"books/1045.html","title":"第二范式(2NF)","keywords":"","body":"第二范式(2NF) 定义2.9 设R(U)是一个关系模式，如果R(U)∈1NF且每个非主属性都完全函数依赖于任一候选码，则称R(U)属于第二范式，记为R(U)∈2NF。 l 第二范式是在第一范式的基础上，增加了条件“每个非主属性都完全函数依赖于任一候选码”，它比第一范式具有更高的要求。 l 如果一个关系模式的候选码都是由一个属性构成，该关系模式肯定属于第二范式，此时每个非主属性都显然完全函数依赖于任一候选码。 l 如果一个关系模式的属性全是主属性，则该关系模式也肯定属于第二范式，此时不存在非主属性。 【例2.7】例2.6中的关系模式SSC(学号, 姓名, 系别, 导师工号, 导师姓名, 导师职称, 课程名称, 课程成绩)。该关系的唯一候选码为{学号, 课程名称}，因此“姓名”, “系别”, “导师工号”, “导师姓名”, “导师职称”, “课程成绩”等6个属性为其非主属性。不存在“学号”相同而“姓名”不同的研究生元组，“姓名”函数依赖于“学号”，即“学号→ 姓名”。非主属性“姓名”并非完全函数依赖于码{学号, 课程名称}，此关系模式不属于第二范式。 因为关系模式SSC仅属于第一范式而不属于第二范式，这决定了它还存在数据冗余、插入异常和删除异常等问题。我们通过模式的投影分解，将之分解为若干个子模式，使得每个子模式都属于第二范式，从而解决上述问题。 先考察关系模式SSC中的函数依赖： 学号→姓名 学号→系别 学号→导师工号 导师工号→导师姓名 导师工号→导师职称 {学号, 课程名称} f→ 课程成绩 由于“学号”和“导师工号”都是单属性，因此上述函数依赖都是完全函数依赖，一共有三种类型，因此在进行投影分解后可得到如下的三个关系模式： Student(学号, 姓名, 系别, 导师工号) supervisor(导师工号, 导师姓名, 导师职称) course(学号, 课程名称, 课程成绩) 这三个关系模式的码分别为学号、导师工号和{学号, 课程名称}，每个关系模式中非主属性都完全函数依赖于码。这三个关系模式都属于第二范式。 利用基于外码的自然连接可以将这三个关系合成原来的关系SSC，即 SSC = student⋈ 导师工号supervisor ⋈学号course。外码的设置如：“导师工号”是student的关于supervisor的外码，“学号”是course的关于student的外码。 l 一个关系模式的码都是由一个属性构成，该关系模式肯定属于第二范式，因为这时每个非主属性都显然完全函数依赖于码。 【例2.8】设有关系模式teacher（课程名, 任课教师名, 任课教师职称），表2.19为关系模式teacher的一张关系表。假设每名教师可以上多门课，每门课只由一名教师上，请问关系模式teacher属于几范式？ 表2.19 关系模式teacher的一个关系表 课程名 任课教师名 任课教师职称 数据库原理 王宁 教授 操作系统 李梦祥 讲师 C语言程序设计 黄思羽 副教授 软件工程 陈光耀 教授 计算机网络原理 王宁 教授 多媒体技术 李梦祥 讲师 关系模式teacher的候选码只有“课程名”，而“任课教师名”和“任课教师职称”都是非主属性。显然有函数依赖集{课程名→任课教师名, 任课教师姓名→任课教师职称, 课程名$\\stackrel{t}{\\rightarrow}$ 任课教师职称}，即每个非主属性都完全依赖于候选码，故关系模式teacher属于2NF。 上例中关系模式teacher属于2NF，仍存在数据冗余和插入、删除操作异常。 【例子】若某任课教师上多门课，则需要在teacher表中存储多次该教师的职称信息（数据冗余）；对于一个新来教师，如果其还没有排课，那么将无法输入该教师的信息，因为课程名作为主码不能为空（插入异常）；又如删除一个任课教师的所有任课记录，则找不到该任课教师姓名和职称信息了（删除异常）。导致这种数据冗余和操作异常的原因在于该关系模式中存在传递函数依赖。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1046.html":{"url":"books/1046.html","title":"第三范式(3NF)","keywords":"","body":"第三范式(3NF) ​ 定义2.10 设R(U)是一个关系模式，如果R(U)∈2NF且每个非主属性都不传递函数依赖于任一候选码，则称R(U)属于第三范式，记为R(U)∈3NF。 ​ 注意，如果一个关系模式的属性全是主属性，那该关系模式肯定属于第三范式，因为该关系模式不存在非主属性。 ​ 【例2.9】假设有一个关于学生选课信息的关系模式——s_c(学号, 课程号, 名次)，其相关语义是：学号和课程号分别是学生和课程的唯一标识属性，每一名学生选修的每门课程有一个名次，且名次不重复。 其函数依赖包括：{学号, 课程号} → 名次，{课程号, 名次} → 学号。{学号, 课程号}和{课程号, 名次}是此关系的候选码。其所有的属性都是主属性，此关系模式属于第三范式。 l 第三范式是在第二范式的基础上，增加了条件“每个非主属性都不传递函数依赖于任一候选码”而得到的。 假设有一个关于员工信息的关系模式：emp_info(Eno, Ename, Dept, Dleader)。其中，Eno为员工编号，Ename为员工姓名，Dept为员工所在部门，Dleader为部门领导。请说明该关系模式属于第几范式以及它存在的问题。 员工编号是唯一的，每个员工只属于一个部门，每个部门只有一个领导（这里假设领导不属于员工范畴，且不考虑纵向领导关系）。员工编号（Eno）为唯一的码，由此容易推出： Eno → Ename Eno → Dept Eno → Dleader 显这些函数依赖都是完全函数依赖。这些函数依赖说明了所有非主属性都完全函数依赖于码Eno，所以关系模式emp_info属于第二范式。但该关系模式还存在下列的函数依赖： Eno→Dept Dept→Dleader Eno→Dleader 上述说明非主属性Dleader传递函数依赖于码Eno，即关系模式emp_info中存在传递函数依赖，它不属于第三范式。传递函数依赖的存在同样会导致一定程度的数据冗余以及插入异常和删除异常等问题。这体现在： 一个部门有多个员工，每一个员工在关系emp_info中都形成一个元组。该元组除了包含员工编号和姓名外，还包含所在部门和部门领导的信息。后两项信息会多次重复出现，重复的次数与部门的员工数相等。这是数据冗余的根源。 数据冗余的存在导致数据维护成本增加。 当一个部门刚成立时，如果还没有招员工，那么将无法输入部门和部门领导的信息（主码Eno的输入值不能为null）。这就造成了插入异常。 出于某些原因，部门的员工可能全部辞职，或者暂时全部转到其他部门去时，需要将所有的员工信息全部删除，这时部门和部门领导的信息也将被删除。这就导致了删除异常。 l 为消除传递函数依赖，可以使用投影分解法将关系模式分解成相应的若干个模式 【例子】根据存在的传递链“Eno→Dept→Dleader”，可以从节点“Dept”上将此传递链切开，形成以下两个模式： ​ emp_info2(Eno, Ename, Dept) ​ dept_info2(Dept, Dleader) 关系模式emp_info2的码为Eno，dept_info2的码为Dept。 l 在消除传递函数依赖后得到的两个关系模式emp_info2和dept_info2都属于第三范式，它们当中都不存在传递函数依赖。 ​ 【例子】可以在没有员工信息的前提下插入部门信息；可以删除所有的员工信息而不影响部门信息；数据冗余度也有所降低了，从而也简化了其他的一些操作等。 l 属于3NF的关系模式主要是消除了非主属性对于候选的传递函数依赖和部分函数依赖，但并没有考虑主属性和候选码之间的依赖关系。它们之间存在的一些依赖关系也会引起数据冗余和操作异常等问题。人们提出了更高一级的范式——BC范式。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1047.html":{"url":"books/1047.html","title":"BC范式(BCNF)","keywords":"","body":"BC范式(BCNF) ​ 定义2.11 设R(U)是一个关系模式且R(U) ∈1NF，如果对于R(U)中任意一个非平凡的函数依赖B→C，B必含有候选码，则称R(U)属于BC范式，记为R(U)∈BCNF。 如果要求B→C为非平凡的且完全的，则要求该函数依赖的决定因素为候选码即可。 在BC范式的定义中并没有明确提出其中的关系要属于3NF，但是该定义确实保证了“其非主属性既不部分函数依赖于候选码，也不传递函数依赖于候选码”，因而BCNF为3NF的一个子集，即BCNF⊆3NF。 对于BC范式中的每一个关系R(U)，它们具有下列的性质： R(U)中的每一个非主属性都完全函数依赖于任何一个候选码。假设存在一个非主属性attr部分函数依赖于一个候选码$B_0$，即$B_0$ $\\stackrel{p}{\\rightarrow}$ attr。由部分函数依赖的定义，必存在B0的一个真子集B0′，使得B0′→attr。由于B0′→attr是一个非平凡函数依赖。根据BCNF的定义，B0′必包含某一个候选码C0。由于候选码B0的真子集包含该候选码C0，所以B0也包含C0且C0异于B0。这说明一个候选码包含一个异于自己的另外一个候选码，这是不可能的。 R(U)中的每一个主属性完全函数依赖于任何一个不包含它的候选码。假设存在一个主属性attr并非完全函数依赖于某一个不包含它的候选码B0。当选择该候选码B0为主码时，attr也不完全函数依赖于主码B0。这与主码的定义相矛盾。 R(U)中没有属性完全函数依赖于非候选码（包括主码）的属性集。假设存在一个异于任何一个候选码的属性集B0和某一个属性attr，使得属性attr完全函数依赖于B0，即B0 $\\stackrel{f}{\\rightarrow}$attr。但由于B0 $\\stackrel{f}{\\rightarrow}$attr，所以显然有B→attr。由BCNF的定义，B0必包含某一个候选码C0。因为B0异于任何一个候选码，所以B0≠C0，因而B0真包含C0，C0为B0的一个真子集。由于C0为候选码，所以C0→attr。这说明，存在B0的一个真子集C0，使得C0→attr。但这与B0 $\\stackrel{f}{\\rightarrow}$ attr相矛盾。 ​ 定理2.3 设R(U)是一个关系模式，且R(U)$\\in$3NF，如果R(U)只有一个候选码，则R(U)$\\in$BCNF。 ​ 证明：对于R(U)中任意一个非平凡函数依赖C→D，假设R(U)唯一的候选码为B，只要证明C包含B即可。 ​ 假设C不包含B，即B ⊄ C。由于B为候选码，所以B $\\stackrel{f}{\\rightarrow}$ U，进而可知B→U。因为C和D都为U的子集，所以由Armstrong公理，U→C，U→D，于是B→C，B→D；由于C→D为非平凡函数依赖，所以D ⊄C；由于C是任意的，所以C B；加上条件假设B ⊄C，于是： ​ D ⊄ C，B ⊄ C，C $ \\rightarrow \\mkern-16.5mu/ $ B ​ B→C ​ C→D ​ B→D ​ D传递依赖于B，这与R∈3NF矛盾。证毕。 ​ 特别地，在一个属于3NF的关系中，当仅有一个属性能够唯一标识每个元组时，则这个关系属于BCNF，且该属性为唯一的候选码（也只能以它为主码）。 【例2.11】观察例2.10中分解后形成的关系模式：emp_info2(Eno, Ename, Dept) 该关系模式中既没有部分函数依赖也没有传递依赖，所以属于3NF。且由于仅有唯一的属性Eno能够唯一标识每一个元组，所以这个关系属于BCNF。 定理2.3看起来非常简单，但它非常有用。在许多情况下，设计的关系往往都是有且仅有一个能够唯一标识每一个元组的属性，这时只要保证不存在对该属性的部分函数依赖和传递函数依赖即可保证该关系属于BCNF，而不用对BCNF的定义进行验证，从而避免了复杂的验证过程，提高设计效率。 定理2.3中的条件只是一个关系属于BCNF的充分条件，但不是必要条件。也就是说，满足该定理条件的关系必属于BCNF，但不满足该定理条件的关系也可能属于BCNF，如例2.12。 【例2.12】 对于学生住宿关系模式StuDom(学号, 姓名系别, 宿舍)而言，假定“姓名”属性也具有唯一性，那么关系模式StuDom拥有两个由单属性组成的候选码，分别是“学号”和“姓名”。由于非主属性，即“系别”和“宿舍”，不存在对任一候选码的部分或传递函数依赖，所以关系模式StuDom属于第三范式。同时关系模式StuDom中除“学号”和“姓名”外没有其它决定因素，所以StuDom关系模式属于BC范式。 此例中，关系模式StuDom有两个候选码，分别是“学号”和“姓名”，而不是只有一个候选码（不满足定理2.3的条件），但它却属于BC范式。 那么有没有属于第三范式的关系模式却不属于BC范式的情况呢？ 【例2.13】对教学关系模式Teach(学生, 教师, 课程)，若每一名教师只教授一门课，每门课可由多名任课教师教授，某一名学生选定某门课即对应一个固定的教师。得到下述函数依赖集： ​ {学生, 课程}→教师 ​ {学生, 教师}→课程 ​ 教师→课程 {学生, 课程}和{学生, 教师}均是候选码。因为没有任何非主属性对码的传递函数依赖或部分函数依赖，故关系模式Teach属于三范式。关系模式Teach不属于BC范式，因为函数依赖“教师→课程”的决定因素——“教师”不含任一候选码。 如果一个关系模型中的关系模式都属于BCNF，则称该关系模型满足BCNF，称基于该关系模型的关系数据库满足BCNF。 一个满足BCNF的关系数据库已经极大地减少数据的冗余，对所有关系模式实现了较为彻底的分解，消除了插入异常和删除异常，已经达到了基于函数依赖为测度的最高规范化程度。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1048.html":{"url":"books/1048.html","title":"分解与规范化","keywords":"","body":"分解与规范化 关系模式的规范化 关系模式的规范化实际上就是通过模式分解将一个较低范式的关系模式转化为多个较高范式的关系模式的过程。 从范式变化的角度看，关系模式的规范化是一个不断增加约束条件的过程； 从关系模式变化的角度看，规范化是关系模式的一个逐步分解的过程。 关系模式的分解是关系模式规范化的本质问题，其目的是实现概念的单一化，即使得一个关系仅描述一个概念或概念间的一个种联系。通过分解可以将一个关系模式分成多个满足更高要求的关系模式，这些关系模式可以在一定程度上解决或缓解数据冗余、更新异常、插入异常、删除异常等问题。 关系模式分解实际上又是一个关系模式的属性投影和属性重组的过程，又称投影分解。投影和重组的基本指导思想是逐步消除数据依赖中不适合的成分，结果将产生多个属于更高级别范式的关系模式。 投影分解的步骤就是低级范式到高级范式转化的步骤，具体步骤是： 基于消除关系模式中非主属性对候选码的函数依赖的原则，对1NF关系模式进行合理的投影（属性重组），结果将产生多个2NF关系模式。 基于消除关系模式中非主属性对候选码的传递函数依赖的原则，对2NF关系模式进行合理的投影，结果将产生多个3NF关系模式。 基于消除关系模式中主属性对候选码的传递函数依赖的原则，对3NF关系模式进行合理的投影，结果将产生多个BCNF关系模式。 关系模式的分解 连接无损分解 ​ 定义2.12 假设一个关系模式R(U)被分解成n个子关系模式：R1(U1),R2(U2),…, Rn(Un)，其中U =R1(U1)∪R2(U2)∪…∪Rn(Un)，并假设r, r1, r2,…, rn分别属于关系模式R(U)及n个子关系模式的关系（二维表），如果这n个子关系的自然连接与原关系r相等，即r = r1 ⋈ r2 ⋈ … ⋈ rn，那么这种分解称为（自然）连接无损分解，其中ri是r在Ui上的投影, i = 1,2,…n。 分解的基本思想之一是消除对候选码的部分函数依赖和传递函数依赖。我们可以先在待分解的关系模式中找出这些部分函数依赖和传递函数依赖以及完全函数依赖，然后“分解”部分函数依赖和传递函数依赖，使得这些函数依赖最终都变成完全函数依赖，最后将这些完全函数依赖所涉及的属性分别投影成新的关系即可。 定理2.4 假设S和T为关系模式R分解后所得到的两个关系模式，则该分解为连接无损分解的充分必要条件是：(S∩T) → (S-T)或(S∩T) → (T-S) 【例2.14】对于例2.6中的关系模式SSC(学号, 姓名, 系别, 导师工号, 导师姓名, 导师职称, 课程名称, 课程成绩)，请运用模式分解方法将其转化为若干个属于BC范式的关系模式。 关系模式SSC中唯一的候选码为{学号, 课程名称}。我们先找出对候选码的所有完全函数依赖、部分函数依赖和传递函数依赖： • {学号, 课程名称} 课程成绩 • {学号, 课程名称} {姓名, 系别} • {学号, 课程名称} 导师工号 • 导师工号 {导师姓名, 导师职称} • {学号, 课程名称} {导师姓名, 导师职称} 以下找出部分函数依赖中的完全函数依赖： 由“{学号, 课程名称} {姓名, 系别}”得到“学号 {姓名, 系别}” 由“{学号, 课程名称} 导师工号 ”得到“学号 导师工号” 我们根据以上所有的完全函数依赖初步设定分解成的各关系模式（原则是“一个完全函数依即为一个关系模式”）： T1(学号, 课程名称, 课程成绩) T2(导师工号, 导师姓名, 导师职称) T3(学号, 姓名, 系别) T4(学号, 导师工号) 为了减少数据冗余和减少数据维护的复杂性，可以将关系模式T4(学号, 导师工号)并到T3(学号, 姓名, 系别)中，从而形成新的关系模式——T3′(学号, 姓名, 系别, 导师工号)。这样，就得到如下的分解结果： T1(学号, 课程名称, 课程成绩) T2(导师工号, 导师姓名, 导师职称) T3(学号, 姓名, 系别, 导师工号) 由定理2.3稍加分析可以知道，以上三个关系模式均属于BC范式，而且上述的分解是连接无损分解。 保持函数依赖的分解 定义2.13 设R(U)是一个关系模式，F为R(U)的一个函数依赖集，B,C为R(U)所涉及的属性集的子集。如果利用Armstrong公理系统中的推理规则能够从函数依赖集F中推出B→C，则称F逻辑蕴涵B→C。F所逻辑蕴涵的函数依赖的集合称为F的闭包，记为$F^+$。 定义2.14 设一个关系模式R(U)被分解成n个关系模式：R1, R2,…, Rn，F为R(U)的属性间函数依赖的集合，F1, F2,…, Fn分别为F在R1, R2,…, Rn上的投影。对于任意F所逻辑蕴涵的函数依赖B→C，总存在某一个$F_i$，使得Fi逻辑蕴涵B→C，则这种分解称为保持函数依赖的分解。 既保持函数依赖又具有自然连接无损的分解 连接无损分解和保持函数依赖的分解是两个相互独立的模式分解。但它们的优缺点具有一定的互补性。 连接无损分解可以保证分解所得到的关系模式经过自然连接后又得到原关系模式，不会造成信息的丢失。这种分解可能带来数据冗余、更新冲突等问题。 原因：连接无损分解不是按照关系模式所蕴涵数据语义来进行分解。而保持函数依赖的分解则正好是按照数据语义来进行分解，它可以使分解后的关系模式相互独立。避免由连接无损分解带来的问题，但它在某些情况下可能造成信息丢失。一个自然的想法就是构造这样的分解：该分解既是保持函数依赖的分解，又具有自然连接无损的特性。这种分解就称为既保持函数依赖又具有自然连接无损的分解。 【例2.15】 考虑例2.10中的关系模式：emp_info(Eno, Ename, Dept, Dleader) Eno为员工编号，Ename为员工姓名，Dept为员工所在部门，Dleader为部门领导。如果将该关系模式分解为：emp_info1(Eno, Ename, Dept)和emp_info2(Eno, Dleader)。易验证，这种分解虽然是连接无损分解，但会造成数据冗余、更新异常等问题。进一步分析还可以发现，该分解不保持函数依赖。例如，函数依赖Dept→Dleader既不被emp_info1的函数依赖集所逻辑蕴涵，也不为emp_info2的函数依赖集所逻辑蕴涵。 现在我们将关系模式emp_info(Eno, Ename, Dept, Dleader)分解成如下的两个模式： emp_info2(Eno, Ename, Dept) dept_info2(Dept, Dleader) 可以验证，这种分解方法保持了函数依赖，同时又具有自然连接无损的特性，它是既保持函数依赖又具有自然连接无损的分解。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1049.html":{"url":"books/1049.html","title":"设计开发技术","keywords":"","body":"设计开发技术 概述 数据库设计是指在现有的应用环境下，从建立问题的概念模型开始，逐步建立和优化问题的逻辑模型，最后建立其高效的物理模型，并据此建立数据库及其应用系统，使之能够有效地收集、存储和管理数据，满足用户的各种应用需求。 数据库设计最终目的：（1）满足用户的需求；（2）简化应用程序的编程设计，实现系统协同、高效的开发，减少开发成本。 数据库设计步骤：系统需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库系统运行和维护。 各步骤的先后关系如图3.1所示。其中，对每一个步骤，如果设计结果不满足要求，都有可以返回前面的任一步骤，直到满足要求为止。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1051.html":{"url":"books/1051.html","title":"需求分析","keywords":"","body":"需求分析 需求分析是了解用户需求、然后明确用户需求、最后形成需求文字表达（需求分析说明书）的一个过程。需求分析的最终结果就是形成一份有效的需求分析说明书（产生数据流图、数据字典、需求说明书）。 系统调研过程 ​ 系统调研也称项目调研，即把系统开发当作项目来运作，其主要目的是通过接触用户以了解并最终明确用户的实际需求。这个过程是一个系统分析人员理解和掌握用户业务流程的过程，是一个需要不断与用户进行沟通和磋商的过程。系统调研方法比较灵活，因人、因系统而异。大致过程可以分为以下几个步骤来完成： 　　充分了解项目背景以及开发的目的。 　　深入用户单位（指使用该系统的机构和组织）进行调查。包括了解单位的组织结构、运作方式，了解各部门的职责和功能。然后从数据流的角度分析各个部分的特性以及它与其他部门之间的关系，如各部门的输入（输出）数据及其格式是什么，这些数据来自哪里、去向何方等，并作相应的记录。 这个步骤是调查的重点，而且难度比较大，难点在于如何建立与用户理性的沟通渠道。用户与系统分析人员一般都具有不同的技术背景，所以经常导致这种情况的出现：用户认为已经说清楚了的东西而分析人员也许对之还不能理解，或者用户提出的要求过高，超出了计算机能够处理的范围等。当出现这种情况时，需要分析人员不断的询问或说明，久了就会导致用户的厌倦。在进行这项调查前分析人员应该做好充分的准备，例如拟好调查方案、设计合理而简洁的调查表等。 ​ 给出了一种调查方法，可供读者参考和选用： 单位情况及其运作方式的介绍。 对部门工作职能的深入了解。 召开调查会。 如果与用户还没有就需求达成共识，相关分析人员可有选择地重复②和③步。 　　确定用户需求、明确系统功能和边界。综合各个分析人员的调查结果，形成系统的功能说明，确定哪些功能是系统要实现的，哪些是不应该实现的，或者是不能实现的。所有这些结果都应该跟用户确认后予以书面形式确定下来。 需求分析的方法 SA方法 针对数据库设计，形成用户需求的有效表达，这种表达在说明书中多以数据流图、数据字典等形式来描述。 为建立用户需求的表达，可以采用多种分析方法来完成。这些方法主要包括自顶向下和自底向上两种方法，其中常采用的方法是自顶向下的结构化分析方法（SA, structured analysis）。 SA方法的分析过程符合人类对问题的认识并最终解决的一般过程，其分析过程简单、实用，现已在众多领域中得到应用。 SA特点可以归结为一棵树的产生过程：先创建树根，然后创建树根节点的子节点，接着创建各子结点的子节点，直到创建所有的树叶节点为止。在这棵树中，树根节点相当于整个系统（第一层次上的系统），其子节点相当于第二层次上的系统，…，最后层次上的系统由叶子节点表示，它对系统分析人员是可认知的（认为已经清楚而不必再分解了）。自顶向下的SA方法是从整个系统开始，采用逐层分解的方式对系统进行分析的方法。 数据流图（data flow diagram） SA方法只是对问题分析的一种思想，在具体的分析过程中还需要借助其他的分析工具，这样才能完成对分析过程和结果的记录、对用户需求的表达等，数据流图就是最为常用的辅助分析工具和描述手段。 数据流图是以图形的方式来刻画数据处理系统中信息的转变和传递过程，是对现实世界中实际系统的一种逻辑抽象表示，但又独立于具体的计算机系统。 数据流图常采用的符号： 数据流 数据流是流动中的数据。所以数据流图是用有方向的曲线或直线来表示，用前头表示数据流的方向，其旁边标以数据流的名称，其格式如下： 数据流名不是随意取的，它能够简要地概括数据流的含义，且易于理解。下文提到的数据名、加工名、文件名等都有同样的要求。 数据流可以来自数据的源点、加工和数据文件，可以流向数据的终点、加工和数据文件。当数据取自文件或者流向文件时，相应的有向直线或曲线可以不命名，因为从相应的文件中即可知道流动的是什么数据。 数据的源点和终点 系统中的数据是来自系统以外的其他数据对象，其最终的流向也是系统以外的有关数据对象。 这种向系统提供数据的数据对象统称为系统的数据源点，而系统数据所流向的数据对象则统称为数据终点。这两个概念的引入是为了帮助用户对系统接口界面的理解。 在数据流图中，数据源点和数据终点都是用方框来表示，方框中标以数据的名称。其格式如下： 加工 加工是对数据处理的一个抽象表示。如果这种“加工”还不为系统分析员所理解，则需要SA方法对其进行分解，直到所得到的加工已经足够简单、不必再分时为止。这时的加工也称为基本加工。在数据流图中，加工是用圆圈（或椭圆）表示，圆圈标以加工的名称。其格式如下： 数据文件 数据文件是表示数据临时存放的地方，“加工”能够对其进行数据读取或存入。在数据流图中，数据文件通常用平行的双节线表示，旁边标以数据文件名。其格式如下： 　　对于数据流图中的一个节点，可能有几条表示数据流的有向线出自或指向该节点。该节点对数据流的影响方式（流出情况）或这几股数据流对该节点的作用方式是有多种的。这种影响和作用方式说明如下表所示。 数据流的关系 基于数据流图的SA方法 自顶向下的SA分析方法可以与数据流图有机地结合起来，将对系统的分析过程和结果形象地表示出来。 在数据流图中，SA分析方法主要体现在对“加工”进行分解的过程。对数据流图的绘制和分解过程就是用户需求的分析及其表达的形成过程。 一个系统的数据流图是由多个子图构成，如果加上子图之间的分解关系，就可以形成一棵树。但由于所有的子图通过表示分解关系的边连在一起而形成的树将是很庞大的，无法在同一平面中画出，所以在绘制数据流图时要分为多个子图来画。 绘制的原则一般是，先绘制树根节点对应的子图，然后绘制根节点的子节点所对应的子图，一直绘制到所有叶子节点对应的子图为止。 下面以某中石化集团的样品分析管理系统（一个子系统）的开发为例，介绍数据流图的基本绘制方法。 1）绘制根节点图。从加工粒度上看，根节点图（即根节点对应的数据流图）是最大的数据流图，它是将整个应用系统当作一个加工。 【例子】 对于样品分析管理系统（YPFXMS），其根节点子图如图所示。 YPFXMS的根节点数据流图 2）绘制子节点图。数据流图的根节点不提供任何有用的信息，需要对加工“样品分析管理系统”作进一步的分解。在调研中发现，不是每一种样品都需要分析的，能够分析的是那些已经有计算公式或分析方案的样品，而且送样（被送用于分析的样品）要先存在样品分析员那里，样品分析员则按照某一个原则一次对这些送样进行分析。在送样被分析，还需要对分析的结果进行检查，如果发现分析结果不合格（是指分析手段和方法出错）则返回给样品分析员重新进行分析，分析合格则返回给送样人员。于是，分解后得到如图所示的数据流图。 根节点0的子节点数据流图 形成数据字典 数据流图主要是表示数据和处理之间的关系，但缺乏对数据流、数据文件、加工等图中各个元素进行描述的能力。 数据流图是将用户头脑中的需要转化为机器能够接受的表达的一个中转站，但数据流图表示的信息离机器能够接受的信息还比较远。如果把用户需求和机器表示放在两头，数据流图放在两者之间，那么数据流图更靠近用户需求一些，而相对远离机器表示。 需要引入数据字典的概念，通过数据字典可以加强数据流图的信息表达能力，同时这种表达拉近了与机器表示的距离，使得用户需求从纯粹的逻辑表达逐步转向机器表示，为数据库的实施奠定基础。 与数据流图一样，数据字典也是SA方法中一种有力的工具。数据字典与数据流图结合使用，主要是用于对数据流图中出现的各种元素进行描述，给出所有数据元素的逻辑定义。数据字典是数据流图中数据元素的描述。这种描述是由一系列的条目组成，但不同的应用、不同的系统其组成的条目可能有所不同。至少应该包括数据流、数据文件、加工和数据项等四种条目。 数据项条目 ​ 数据项是数据构成的最小组成单位，它不能再分割。数据项条目用于说明数据项的名称、类型、长度、取值范围等。 例如，在课题管理系统中数据项“课题申请代码”条目可描述如下： 数据项名：课题申请代码 类型：字符型 长度：12 取值范围：000000000000～999999999999 取值说明：前4为年号，第5到第6位、第7到第8位分别表示月份和日期，后4位表示当天的课题序号 数据流条目 ​ 数据流条目主要用于说明数据流的组成（由哪些数据项组成），数据流的来源和流向以及数据流量等信息。 例如，数据流“样品分析请求信息”条目描述如下： 数据流名称：样品分析请求信息 组成：申请表编号、申请表名称、分析项目代码、样品编号、样品名称、送样日期、送样人员 来源：记录送样信息（加工） 去向：样品分析请求信息（文件） 流量：10～20/每天 数据文件条目 ​ 数据文件条目用于说明数据文件是由哪些数据项组成，组织方式、存储频率如何等信息。 例如，数据文件“一审合格实验信息”条目如下： 文件名：一审合格实验信息 数据组成：试验记录表编号、试验记录表名称、试验日期、试验环境、试验目的、 操作人员、原料规格、试验配方与工艺、操作过程与现象、试验结果与讨论、记录人员、试验组长、课题代码 组织方式：按试验记录表编号递增排列 存储频率：1次/天 加工条目 ​ 加工条目主要用于说明加工的逻辑功能、指明输入数据和输出数据等信息。其中逻辑功能项用于指出该加工用来做什么、对加工处理的一些要求等。 例如， 加工编号：1 加 工 名：记录送样信息 输入数据：样品数据 输出数据：样品分析请求信息 逻辑功能：对送检的样品数据进行登记，并由此转化成样品分析请求信息。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1052.html":{"url":"books/1052.html","title":"数据库结构设计","keywords":"","body":"数据库结构设计 * [概念结构设计](books/1053.md) * [E-R图](books/1029.md) * [逻辑结构设计](books/1054.md) * [物理结构设计](books/1055.md) 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1053.html":{"url":"books/1053.html","title":"概念结构设计","keywords":"","body":"概念结构设计 3.1.1概念结构定义 　　需求分析的成果是数据流图和数据字典，概念结构设计的目的就是将抽象转化为信息世界中基于信息结构表示的数据结构——概念结构，即概念结构是用户需求在信息世界中的模型。 　　数据库的概念结构独立于它的逻辑结构，更与数据库的物理结构无关。它是现实世界中用户需求与机器世界中机器表示之间的中转站。它既有易于用户理解、实现分析员与用户交流的优点，也有易于转化为机器表示的特点。当用户的需求发生改变时，概念结构很容易作出相应的调整。所以，概念结构设计是数据库设计的一个重要步骤。 　　概念模式描述的经典工具是E-R图，由E-R图表示的概念模型就是所谓的E-R模型。E-R模型的创建和设计过程就是概念结构的创建和设计过程，概念结构的设计集中体现为E-R模型的设计。 E-R模型的优点： 　　它具有较强的表达能力，可以充分表示各种类型数据及数据之间的联系； 　　数据表达形式简单，没有过多的概念，定义严格，无二义性等； 　　E-R模型是以图形的形式出现，表示直观。 3.1.2设计思想 　　四种概念结构的设计指导思想： 自顶向下：首先根据用户需求定义全局概念结构的E-R模型(产生E-R模型)，然后对其分解，逐步细化。 自底向上：首先根据各个部门的需求定义局部概念结构的E-R模型，然后将这些局部的E-R模型并接成为全局的E-R模型，形成全局概念结构。 先主后次：分析各种子需要的“轻重”，首先设计最重要的概念结构，形成它的E-R模型，然后定义次要概念结构的E-R模型，接着按照类似的方法定义其他所有概念结构的E-R模型，最后将这些模型继承起来，形成全局概念结构。 上下混合：这是指将自顶向下和自底向上这两种方法结合起来使用的一种设计方法。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1029.html":{"url":"books/1029.html","title":"E-R图","keywords":"","body":"E-R图 ​ 概念模型有很多种表示方法,其中最为常用的是 P . P . S . Chen 于1976年提出的实体-联系方法(Entity Relationship Approach )。该方法用 E - R 图来描述现实世界的概念模型,称为实体-联系模型( Entity-Relationship Model , E-R 模型)。 ​ E - R 模型是软件工程设计中的一个重要方法,因为它接近于人的思维方式,容易理解并且与计算机无关,所以用户容易接受,是用户和数据库设计人员交流的语言。但是, E - R 模型只能说明实体间的语义联系,还不能进一步地详细说明数据结构。在解决实际应用问题时,通常先设计一个 E - R 模型,然后再把其转换成计算机能接受的数据模型。 　　利用实体、属性和联系及其之间关系的表示方法可以将现实世界中的复杂问题抽象成为信息世界中的概念模型。概念模型通常是用E-R图表示的，E-R图的设计过程就是对问题进行抽象和建模的过程。 实体 ​ 在 E - R 模型中,实体用矩形表示,通常矩形框内写明实体名。实体是现实世界中可以区别于其他对象的“事件”或“物体”。例如,企业中的每个人都是一个实体。每个实体由一组特性(属性)来表示,其中的某一部分属性可以唯一标识实体,例如职工实体集中的职工号。实体集是具有相同属性的实体集合。例如,学校的所有教师具有相同的属性,因此教师的集合可以定义为一个实体集;学生具有相同的属性,因此学生的集合可以定义为另一个实体集。 　　概念结构设计中，实体集中的实体彼此是可区别的。如果实体集中的属性或最小属性组合的值能唯一标识其对应实体，则将该属性或属性组合称为码。对于每一个实体集，可指定一个码为主码。 　　如果用矩形框表示实体集，用带半圆的矩形框表示属性，用线段连接实体集与属性，当一个属性或属性组合指定为主码时，在实体集与属性的连接线上标记一斜线. 实体是客观存在的并可以相互区分的事物。 实体的属性是指实体所具有的特性。 学生是一个实体，如姓名、性别、成绩等是实体的属性。 码又称关键字，它是一个或者多个属性的集合。 学号是学生实体的码。 属性的域是指一个属性的取值范围。 成绩是学生实体的域。 实体型是指用实体名和实体属性名的集合来共同刻画同一类实体。 学生（学号，姓名，性别，籍贯，成绩）是一个实体型。 实体集就是实体的集合。 实体及其属性的表示 【例子】 对于一个实体型——学生（学号，姓名，成绩），其E-R图如图1.10所示。 学生实体及其属性的E-R图 注意：实体图和E-R图可以分开 联系 在 E - R 模型中,联系用菱形表示,通常菱形框内写明联系名,并用无向边分别与有关实体连接起来,同时在无向边旁标注上联系的类型(1:1、1 : n 或 m : n)。实体的联系分为实体内部的联系和实体与实体之间的联系。实体内部的联系反映数据在同一记录内部各字段间的联系。 定义 是指事物之间的关系（现实世界）在信息世界中的反映。 两种类型 实体内部的联系和实体之间的联系，实体间联系又分为两个实体间和多个实体间。 两个不同实体之间的联系 两个不同实体集之间存在以下3种联系类型。 一对一(1 : 1)。指实体集$E_1$在中的一个实体最多只与实体集$E_2$中的一个实体相联系。 A中的一个实体至多与B中的一个实体相联系，B中的一个实体也至多与A中的一个实体相联系。例如，“班级”与“正班长”这两个实体集之间的联系是一对一的联系，因为一个班级只有一（1）个正班长，反过来，一个正班长只属于一（1）个班级。 一对一联系可以加在A中，也可以加在B中 一对多(1 : n)。表示实体集$E_1$中的一个实体可与实体集$E_2$中的多个实体相联系。 A中的一个实体可以与B中的多个实体相联系，而B中的一个实体至多与A中的一个实体相联系。例如，“班级”与“学生”这两个实体集之间的联系是一对多的联系，因为，一个班级可有若干（n）学生，反过来，一个学生只能属于一个（1）班级。 一对多中，联系加在多中，也可以重新建一个表 多对多( m :n)。表示实体集$E_1$中的多个实体可与实体集$E_2$中的多个实体相联系。 A中的一个实体可以与B中的多个实体相联系，而B中的一个实体也可与A中的多个实体相联系。例如，“学生”与“课程”这两个实体集之间的联系是多对多的联系，因为，一个学生可选多门（n）课程，反过来，一门课程可被多个学生（m）选修。 多对多中，联系重新建一张表 且联系名一定有属性，因为下面转换时，实体A和实体B为组合主键，一个表不可能只有主键 当将现实世界中的实际问题转化为信息世界中的概念模型时，用什么来描述这种概念模型呢?当在数据库理论中，通常用E-R图来描述概念模型 ，它提供了表示实体型、属性和联系的方法。 确定mn时以另一方为单位1，看此路径为多少 转换的基本原则是：实体和联系分别转换成关系，属性转换成相应关系的属性 　　多个实体型（三个或三个以上）之间联系的表示 三个实体型A、B、C之间联系表示为（m:n:o）,其中m,n,o > 0。 对于供应商、仓库和零件，由于一个供应商可以提供多种零件并存放在不同仓库中，而一种零件也可以由多个供应商提供并存放在不同仓库中，同时一个仓库也可以存放不同供应商提供的多种零件。所以供应商、仓库和零件之间的联系是多对多联系，其E-R图可以用下图表示。 三个实体型之间多对多联系 实体型内部联系的表示 　　同一个实体型内部实体的三种联系对应的E-R图，分别如下图的（a）、（b）和（c）所示。 实体型内实体之间的各种联系 联系属性的表示 　　联系的属性的表示方法与实体的类似 对于供应商和仓库之间的联系（库存），其属性（库存量），可以表示如图所示。 实体联系属性的表示 概念结构设计 　　概念结构设计通常采用的是自底向上的设计方法（而需求分析一般是采用自顶向下的方法），即这种方法分为两步： 先建立局部概念结构的E-R模型； 然后将所有的局部E-R模型集成起来形成全局概念结构。 自底向上的概念结构设计方法 步骤一： 局部E-R模型的设计 　　E-R模型的设计基于需求分析阶段产生的数据流图和数据字典来进行。一个系统的数据流图是按分层来绘制，是由多张数据流图构成。基于一张数据流图及其对应的数据字典部分进行的E-R模型设计得到的是一个局部概念。 ​ 实体和实体间联系的划分并无统一的标准，一般采用的划分原则是，先是凭经验，后再作调整。 　　经验是指在一般情况下对于那些具有共同特征和行为的对象，可以将之抽象为实体；对象的共同特征和行为可以抽象为实体的属性。 　　调整是指在凭经验作出抽象后，根据具体的应用和建模环境对实体与其属性之间的关系以及实体与实体之间的关系作出相应的更改，有可能使得原来的属性变为实体，原来是实体的变为属性等，从而也导致了实体间关系的改变。 实体及实体间关系的抽象注意以下三点： （1）在同一应用环境中，被抽象为属性的事物就不能再被抽象为实体了，否则会导致“属性又包含属性”的错误，这违反第一范式； （2）属性具有不可再分性，所以具有不可再分性的事物一般都应抽象为属性，而具有可再分性的事物一般不能抽象为属性； （3）一个事物不能同时被抽象为两个实体的属性，即一个属性只能隶属于一个实体。 步骤二：全局E-R模型的集成 ​ 相对于一个整体而言，以上是E-R局部图，这些E-R图应该能够合成一张总的E-R图。对概念结构来说，就是将局部概念结构集成为全局的概念结构。 ​ 集成方式有：多个局部E-R图一次集成和逐步集成，即用累加的方式一次集成两个局部E-R图 　　局部E-R图的并接过程中产生许多问题，这些问题主要体现为各个局部E-R图之间的冲突，其中包括命名冲突、属性冲突和结构冲突等。 命名冲突：命名冲突是指意义不同的元素在不同的局部E-R图中有相同的名字，或者是有相同意义的元素在不同的局部E-R图中具有不相同的名字。 属性冲突：属性冲突是指同义同名的属性在不同的局部E-R图中的取值类型、范围、所使用的单位等却完全不一样。在一个E-R图中不应该存在属性冲突。 有的将职工编号定义为长度为12个字节的字符串类型，有的则定义为8个字节的字符串类型，有的可能将职工编号定义为整型。 结构冲突：结构冲突是指一个事物在一个局部E-R图被抽象为实体，而在另一个局部E-R图中又被抽象为属性。还有一种结构冲突是相同的实体在不同的局部E-R图中有不同的属性或不同的联系。 这不能直接将这两个局部E-R图并接为一个E-R图，首先要解决结构冲突问题。 解决的办法是，视具体情况将相应的属性改为实体，或者将相应的实体改为属性。 对于前一种情况，一种简单的解决方法是：使该实体的属性集为它在各E-R图中的属性集的并；对于后一种情况，解决方法相对复杂，要视具体情况对联系进行分解，或者进行其他的调整。 在构建的E-R图中，最好不要包含环形结构，因为这容易出现“死循环”参照关系，如果一个E-R图包含环形结构，则需要进一步确认对概念结构的建模是否正确，重新修改E-R图，或者直接将环中的一条边（关联）去掉，以破坏“死循环”结构。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1054.html":{"url":"books/1054.html","title":"逻辑结构设计","keywords":"","body":"逻辑结构设计 数据库的逻辑结构设计就是将以E-R图表示的概念结构转换为DBMS支持的数据模型并对其进行优化的过程。（产生关系模式） 概念结构是由E-R图来描述的，概念结构到关系模型的转换可以归结为E-R图到关系模型的转换问题。E-R图的基本元素是实体、属性和联系等，于是E-R图到关系模型的转换就变成了实体、属性和联系等基本元素到关系模式的转化问题。 实体和属性的转变 这种转变比较简单、直观，即一个实体转化为一个关系模式，其中实体名变成了关系模式的名称，实体属性相应地变成了关系的属性。 【例子】 下图中的三个实体分别转化为以下三个关系模式： 项目（编号，名称，经理，性质，启动时间，结题时间，经费） 部门（编号，名称，经理，人数，地址） 职工（编号，姓名，性别，职称，年龄） 企业管理信息系统的E-R图 （1:1）联系的转变 一对一联系的转变：创建一个独立的关系模式，该关系模式的属性是由该联系本身的属性以及与之相连的实体的候选码（每个实体中取一个候选码）组成。 1 : 1联系的E-R图到关系模式的转换 1∶1的联系既可单独对应一个关系模式，也可以不单独对应一个关系模式。有时候为了减少数据冗余，可以将联系对应的关系合并到与之相连的某一个实体对应的关系中去。 方法：将一个实体的候选码以及联系的属性添加到另一个实体对应的关系中。 可以放在一个里，不用单建表，可以单建表，联系可以合并到任意与之相连的实体对应的关系中。但在实际应用，往往从效率的角度来考虑如何进行合并。 （1）联系单独对应一个关系模式，则由联系属性、参与联系的各实体集的主码属性构成关系模式，其主码可选参与联系的实体集的任一方的主码。 （2）联系不单独对应一个关系模式，联系的属性及一方的主码加入另一方实体集对应的关系模式中。 例如，对于下图描述的“班级（BJB）”与“正班长（BZB）”实体集通过属于（SYB）联系E-R模型，可设计如下关系模式（下横线表示该字段为主码）： BJB（班级编号，院系，专业，人数 ） BZB（学号，姓名） SYB（学号，班级编号） 例如，对于上图描述的“班级（BJB）”与“正班长（BZB）”实体集通过属于（SYB）联系E-R模型，可设计如下关系模式： BJB（班级编号，院系，专业，人数） BZB（学号，姓名，班级编号） 或者 BJB（班级编号，院系，专业，人数，学号） BZB（学号，姓名） 【例子】 一个仓库仅由一个仓库管理员管理，而一个仓库管理员也只能管理一个仓库，所以仓库管理员和仓库之间的联系是管理，管理时间为8小时（一天），其E-R图如图所示。 “仓库管理员”和“仓库”及其联系的E-R图 “仓库管理员”和“仓库”之间的联系是（1:1），该联系转换后形成如下的关系模式： ​ 管理（管理员编号，仓库编号，时间） 管理员编号和仓库编号分别为“仓库管理员”实体和“仓库”实体的候选码，时间是“管理”联系的属性。 对于以上例子，易知“仓库管理员”实体对应的关系如下： ​ 仓库管理员（管理员编号，姓名） 我们只需将“仓库”实体的候选码“仓库编号”以及联系的属性“时间”一起添加到仓库管理员关系中即可，从而实现对联系“管理”的转换，结果得到的关系模式如下： ​ 仓库管理员（管理员编号，姓名，仓库编号，时间） 也可以将“仓库管理员”的候选码和联系的属性“时间”一起添加到仓库关系中，结果得到如下的关系模式： ​ 仓库（仓库编号，仓库规模，管理员编号，时间） （1:n）联系的转变 一对多联系可以转化为一个独立的关系模式，也可以将联系合并到n端对应的关系模式中。 可以放在一个里，不用单建表 1 : n联系的E-R图到关系模式的转换 1∶n的联系既可单独对应一个关系模式，也可以不单独对应一个关系模式。 （1）若联系单独对应一个关系模式，则由联系的属性、参与联系的各实体集的主码属性构成关系模式，n端的主码作为该关系模式的主码。 （2）若联系不单独对应一个关系模式，则将联系的属性及1端的主码加入n端实体集对应的关系模式中，主码仍为n端的主码。 企业管理信息系统的E-R图 【例子】 对于上图所示的E-R图，“拥有”联系是一对多联系，当把这个联系转化为独立的关系模式时，则得到如下的关系模式： 拥有（职工编号，部门编号） 用合并的方法对该联系进行转换，则得到如下的关系模式： 职工（职工编号，姓名，性别，年龄，职称，部门编号） ​ 其中，以上的“编号”属性都是相应实体的主码。 例如，对于下图描述的“班级（BJB）”与“学生（XSB）”实体集E-R模型，可设计如下关系模式： BJB（班级编号，院系，专业，人数） XSB （学号，姓名，性别，出生时间，专业，总学分，备注） SYB （学号，班级编号） 例如，对于上图描述的“班级（BJB）”与“学生（XSB）”实体集E-R模型，可设计如下关系模式： BJB（班级编号，院系，专业，人数） XSB （学号，姓名，性别，出生时间，专业，总学分，备注，班级编号） （m:n）联系的转变 多对多必须建立一个表，且表的主键为两个实体的组合主键 多对多联系只能转换为一个独立的关系模式，其属性集是由与该联系相连的实体的属性（码）以及该联系本身的属性转换而得到的。 m : n联系的E-R图到关系模式的转换 m : n的联系单独对应一个关系模式，该关系模式包括联系的属性、参与联系的各实体集的主码属性，该关系模式的主码由各实体集的主码属性共同组成。 【例子】 一个仓库可以存放多种零件，一种零件也可以存放在多个仓库中，可见仓库和零件之间的联系——“存放”是（m:n）联系。假设其E-R图如图所示。 “仓库”和“零件”及其联系的E-R图 “存放”联系转换为独立的关系模式后，结果如下： 存放（仓库编号，零件编号，数量） “学生”与“课程”实体集间的E-R模型 例如，对于图描述的“学生（XSB）”与“课程（KCB）”实体集之间的联系可设计如下关系模式： XSB（学号，姓名，性别，出生时间，专业，总学分，备注） KCB（课程号，课程名称，开课学期，学时，学分） CJB（学号，课程号，成绩） 关系模式CJB的主码是由“学号”和“课程号”两个属性组合起来构成的一个主码，一个关系模式只能有一个主码。 应用规范化理论实现逻辑结构的优化 逻辑结构设计的结果是数据模型。以上主要介绍了如何将以E-R图表示的概念结构转化为以关系模型表示的逻辑结构。在形成关系模式后，还需要对其进行优化处理，以尽可能地减少数据冗余、删除冲突和插入冲突等问题。 用户子模式的设计 用户子模式也称为外模式，它是面向用户的，是用户可见的数据模型部分。它可以屏蔽概念模式，有助于实现程序与数据的独立，可以满足不同用户对数据的个性化需求，同时也有利于数据库的管理。 用户子模式的设计主要是利用局部E-R图，因为每一张E-R图一般都是表示局部概念结构。现在流行的DBMS一般都提供了视图功能，支持用户的虚拟视图。我们可以利用这个功能设计符合不同局部应用需要的用户子模式。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1055.html":{"url":"books/1055.html","title":"物理结构设计","keywords":"","body":"物理结构设计 物理结构设计就是为既定的数据模型选取特定的、有效的存储结构和存储路径的过程。特定性是指跟具体的计算机系统有关，包括操作系统和DBMS等；有效性是指以尽可能少的系统资源获取数据库尽可能高的运行效率。 物理结构设计的内容主要包括数据库存储结构的确定和数据库存取方法的确定。 数据的物理模型指数据的存储结构，如对数据库物理文件、索引文件的组织方式、文件的存取路径，内存的管理等。物理模型对用户是不可见的，它不仅与数据库管理系统有关，还与操作系统甚至硬件有关。 数据库存储结构的设计 任务：确定数据的存放位置和使用的存储结构，确定在磁盘空间中存储关系、索引、日志、备份等的数据库文件，设置系统存储参数，目的是使得以最小的系统资源获取最高的系统性能。 存储结构的设计是在已选定的DBMS和硬件条件下进行的，主要从以下两个方面考虑: （1）确定数据的存放方式 在大多的关系DBMS中，数据的分类和指定存储是通过数据文件的划分和存储来实现。 在DBMS中，不能直接指定数据的存放位置，而只能通过一定的机制实现数据文件的指定存放，从而实现将数据存放在指定的位置。确定了数据文件的存放位置也就确定了数据的存放位置。 数据文件的划分和存储主要是基于数据访问的稳定性、安全性、效率等方面考虑的，相应的指导性规则包括： 数据库文件和日志文件应该分开存放在磁盘中。 如果计算机系统中有多个磁盘，可以将数据库文件分为多个文件，并分布在不同的磁盘中。 +　　将数据表和索引等分开存放在不同的数据库文件中。 +　　大的数据对象要分散存储在不同的数据库文件中。 （2）确定系统参数的配置 系统参数是指DBMS提供设置参数。这些参数主要包括数据库的大小、同时连接的用户数、缓冲区个数和大小、索引文件的大小、填充因子等。DBMS一般都对这些参数设置了初始值，但这些设置并不一定适应每一种应用环境，这需要设计人员重新设计。 这些参数的配置操作一般都可以在DBMS提供管理工具中完成。 【例子】 SQL Server 2008提供的管理工具是SQL Server Management Studio（SSMS），SSMS可以管理SQL Server 2008的所有组件，包括访问、配置、控制和开发这些组件。 确定存取方法 　　存取方法即关系模式的存取方法，目的是实现数据的快速存取。每一种DBMS都提供了多种不同的存取方法，索引法是最常用的一种，在实际开发当中用得最多。以下重点介绍索引法。 索引为什么可以提高数据库中数据的存取速度呢？ 　　这道理与目录可以提高书的查阅速度的道理一样，即可以将索引形象地比喻为目录。索引正是基于目录的原理来设计，它是“数据标题”和数据内存地址的列表。通过索引可以从部分数据检索中实现数据的快速查找，从而提高数据的查询效率。 索引的创建并不是无代价的。 　　索引本身也是一种数据表，同样占用存储资源，而且要保持与数据表的同步，这要求在进行数据更新操作（包括添加、删除和修改操作）时也要对索引进行相应的更新操作。如果索引很大时，其占用的空间资源以及对其更新维护所需要的代价同样是非常可观的。对索引的创建与否，应该慎重考虑。 在创建索引时，几个经验性的指导原则： +　　　　在经常用于检索的列上创建索引，特别是要对主码创建索引（一般是由DBMS自动完成）。 +　　　　在外键上创建索引，因为它经常用于与其他关系进行连接查询。 +　　　　多在以读为主或者经常需要排列的列上创建索引。因为索引已经排序，它可以加快读取速度和排序效率。 +　　　　多在经常用于条件查询的列上创建索引，特别是对那些常常出现少量元组满足条件的列。 +　　　　而对具有以下性质的列，则不宜对其创建索引： 　　　　　　对于不经常用于检索的列，则不宜在其上创建索引。 　　　　　　对于那些值域很小的列不应该创建索引。 　　　　　　对于值域严重分布不均匀的列不宜在其上创建索引。 　　　　　　对于更新操作非常频繁的列，不宜在其上创建索引。 　　　　　　对于长度超过30个字节的列，一般不要在其上创建索引。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1056.html":{"url":"books/1056.html","title":"数据库实施","keywords":"","body":"数据库实施 数据库实施包括以下几方面的内容： 建立数据库结构 根据物理结构的设计结果，选定相应的DBMS。然后在该DBMS系统中利用其提供的DDL语言建立数据库结构。 例如，在SQL Server中，可用下列的SQL语句来分别创建数据库和数据表： CREATE DATABASE database_name CREATE TABLE table_name 在数据库结构定义以后，通过DBMS提供的编译处理程序编译后即可形成了实际可运行的数据库。但这时的数据库还仅仅一个框架，内容是空的。要真正发挥它的作用，还需要编写相应的应用程序，将数据保存在其中，形成一个“有血有肉”的动态系统。 装载测试数据，编写调试应用程序 应用程序设计与数据库设计可以同时进行，应用程序的代码编写和调试则在数据库结构创建以后进行的。 应用程序的编写和调试是一个反复进行的过程，其中需要对数据库进行测试性访问。这时应该在数据库中装载一些测试数据。这些数据可以随机产生，也可以用实际数据作为测试数据（但这些实际数据要留有副本）。 试运行 　　在应用程序调试以后，给数据库加载一些实际数据并运行应用程序，但还没有正式投入使用，而只是想查看数据库应用系统各方面的功能，那么这种运行就称为试运行，试运行也称联合调试， 　　试运行与调试的区别：两者目的基本一样，但侧重点有所不同。调试主要是为了发现系统中可能存在的错误，以便及时纠正；试运行虽然也需要发现错误，但它更注重于系统性能的检测和评价。 　　试运行的主要工作包括 系统性能检测。包括测试系统的稳定性、安全性和效率等方面的指标，查看是否符合设计时设定的目标。 系统功能检测。运行系统，按各个功能模块逐项检测，检查系统的各个功能模块是否能够完成既定的功能。 如果检测结果不符合设计目标，则返回相应的设计阶段，重新修改程序代码或数据库结构，直到满足要求为止。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1057.html":{"url":"books/1057.html","title":"运行和维护","keywords":"","body":"数据库系统的运行和维护 试运行结束并被证实符合设计要求后，数据库就可以正式投入使用。 数据库的正式使用标志着数据库开发阶段的基本结束，同时意味着数据库运行和维护阶段的开始。 数据库的运行和维护并不是数据库设计的终点，而是数据库设计的延续和提高。 数据库的日常运行和维护也是一项专业性很强的工作，需要很强的专业技术。维护工作不是普通的用户就能够胜任的，一般是由系统管理员（DBA）完成。这种工作就是软件产生品的售后服务。 在数据库的运行和维护阶段，DBA的主要工作包括： 数据库的转储和恢复 一旦数据库正式投入使用，企业的相关数据将全部存入数据库（一般不会另记在纸质材料中）。如果数据库发生故障，可能会导致这些数据的丢失，从而造成企业的重大损失。为了尽量避免在数据库发生故障时造成数据丢失，DBA应当根据应用的具体要求指定相应的备份和恢复方案，保证一旦发生故障，能够尽快将数据库恢复到某一种一致性的最近状态，尽量减少损失。 数据库转储：数据库恢复技术，是指定期地把整个数据库复制到磁盘或者其他存储设备上保护起来的过程。数据库的转储和恢复是数据库运行维护中最重要的工作之一。 数据库性能的检测、分析和改善 随着运行时间的增加，数据库的物理存储不断发生改变，加上数据量和用户的不断增加，这都使得数据库的运行性能不断下降。DBA必须利用DBMS提供的性能监控和分析工具定期地对数据库的各种性能指标进行检测，以便及早地发现问题并采取相应的优化和改善措施。 数据库的安全性和完整性维护 不管是从企业内部还是从企业外部来讲，数据库的安全性和完整性都是至关重要的。作为数据库的管理者，DBA必须对数据库的安全性和完整性负责。DBA应该认真审核每一个用户的身份，并正确授予相应的权限；随着时间的推移和应用环境的改变，对安全性的要求也随之发生变化，这要求DBA对数据库的安全性控制作出相应的调整，以适应新的情况。类似地，数据库的完整性约束条件也会发生变化，这同样要求DBA作出相应的修正，以满足新的要求。 数据库的重组和重构 　　数据的插入、修改和删除是数据库的基本操作。这些操作的多次使用会使得数据在磁盘上的存储分布越来越散，导致数据的存储效率降低，整个系统性能下降。这时应该对数据库进行重新组织（即重组），以提高系统的性能。现在流行的DBMS一般都提供重组功能。 　　数据库的重构:对数据库的模式和内模式进行调整，如增加或删除某些列和表、增加或删除某些索引、修改数据库的完整性约束条件等，这种调整就是对数据库进行重新构造的过程。 　　数据库重组和数据库重构有着本质的区别： 数据库重组的目的：提高系统的性能，通过DBMS提供的功能对数据库在磁盘上的存储分布进行调整来达到重组的目的，重组不会改变数据库的模式和内模式； 数据库重构的目的：实现新的用户需求，需要修改数据库结构，从而使得数据库的概念模式和内模式也被修改。 　　不是在迫不得以的情况下，不要使用数据库重构。数据库重构不但使数据库结构发生了改变，而且在多数情况下也要求应用程序作出相应的修改。这会导致“牵一发而动全身”的后果，由数据库重构而引起的修改工作量是非常大的。 　　数据库重构并不是“无所不能”，数据库重构可以实现新的用户需求，但这种需求的变化幅度必须限制在一定的范围内。超过这个范围，数据库重构可能无法实现，也可能是实现的代价太高而失去重构的意义。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1058.html":{"url":"books/1058.html","title":"数据库连接技术","keywords":"","body":"数据库连接技术 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1059.html":{"url":"books/1059.html","title":"数据库接口","keywords":"","body":"数据库接口 1.1ODBC数据库接口 ODBC即开放式数据库互连（Open DataBase Connectivity），是微软公司推出的一种实现应用程序和关系数据库之间通信的接口标准。符合标准的数据库就可以通过SQL语言编写的命令对数据库进行操作，但只针对关系数据库。目前所有的关系数据库都符合该标准（如SQL Server，Oracle，Access，Excel等）。 ODBC本质上是一组数据库访问API（应用程序编程接口），它由一组函数调用组成，核心是SQL语句，其结构如图所示。 ODBC数据库接口 1.2OLE DB数据库接口 OLE DB即数据库链接和嵌入对象（Object Linking and EMBedding DataBase）。OLE DB是微软提出的基于COM思想且面向对象的一种技术标准，其目的是提供一种统一的数据访问接口来访问各种数据源。 这里所说的“数据”除了标准的关系型数据库中的数据之外，还包括邮件数据、Web上的文本或图形、目录服务（Directory Services）、主机系统中的文件和地理数据以及自定义业务对象等。 OLE DB标准的核心内容就是，提供一种相同的访问接口，使得数据的使用者（应用程序）可以使用同样的方法访问各种数据，而不用考虑数据的具体存储地点、格式或类型，其结构如图所示。 OLE DB数据库接口 1.3ADO数据库接口 ADO（ActiveX Data Objects）是微软公司开发的基于COM的数据库应用程序接口，通过ADO连接数据库，可以灵活地操作数据库中的数据。 下图所示为应用程序通过ADO访问SQL Server数据库接口。从图中可看出，使用ADO访问SQL Server数据库有两种途径：一种是通过ODBC驱动程序，另一种是通过SQL Server专用的OLE DB Provider，后者有更高的访问效率。 ado整合了odbc oledb ADO访问SQL Server的接口 1.4ADO.NET数据库接口 ASP.NET使用ADO.NET数据模型。该模型从ADO发展而来，但它不只是对ADO的改进，而是采用了一种全新的技术。主要表现在以下几个方面。 （1）ADO.NET 不是采用 ActiveX 技术，而是与.NET框架紧密结合的产物。 （2）ADO.NET 包含对 XML标准的完全支持，这对于跨平台交换数据具有重要的意义。 （3）ADO.NET 既能在与数据源连接的环境下工作，又能在断开与数据源连接的条件下工作。特别是后者，非常适合于网络应用的需要。因为在网络环境下，保持与数据源连接，不符合网站的要求，不仅效率低，付出的代价高，而且常常会引发多个用户同时访问带来的冲突。因此ADO.NET系统集中主要精力来解决在断开与数据源连接的条件下的数据处理问题。 ADO.NET 提供了面向对象的数据库视图，并且在ADO.NET 对象中封装了许多数据库属性和关系。最重要的是，ADO.NET 通过多种方式封装和隐藏了很多数据库访问的细节。用户可以完全不知道对象在与 ADO.NET 对象交互，也不用担心数据移动到另外一个数据库或者从另一个数据库获得数据的细节问题。下图所示为ADO.NET 架构总览。 通过ADO.NET访问数据库的接口模型 1.5JDBC数据库接口 在JDBC API中有两层接口：应用程序层和驱动程序层，前者使开发人员可以通过SQL调用数据库和取得结果，后者处理与具体数据库驱动程序相关的所有通信。 使用JDBC接口对数据库操作有如下优点： （1）JDBC API与ODBC十分相似，有利于用户理解。 （2）使编程人员从复杂的驱动器调用命令和函数中解脱出来，而致力于应用程序功能的实现。 （3）JDBC支持不同的关系数据库，增强了程序的可移植性。 使用JDBC的主要缺点：访问数据记录的速度会受到一定影响；此外，JDBC结构中包含了不同厂家的产品，这给数据源的更改带来了较大麻烦。 1.6数据库连接池技术 网络环境下的数据库应用，由于用户众多，使用传统的JDBC方式进行数据库连接，系统资源开销过大，这成为制约大型企业级应用效率的瓶颈，而采用数据库连接池技术对数据库连接进行管理，可以大大提高系统的效率和稳定性。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1060.html":{"url":"books/1060.html","title":"模式","keywords":"","body":"模式 客户-服务器（C/S）模式应用系统 对于一般的数据库应用系统，除了数据库管理系统外，需要设计适合普通人员操作数据库的界面。目前，流行的开发数据库界面的工具主要包括Visual BASIC、Visual C++、Visual FoxPro、Delphi、PowerBuilder等。数据库应用程序与数据库、数据库管理系统之间的关系如图所示。 数据库应用程序与数据库、数据库管理系统之间的关系 应用程序和数据库管理系统可以运行在同一台计算机上（单机方式），也可以运行在网络方式下。在网络方式下，数据库管理系统在网络上的一台主机上运行，应用程序可以在网络上的多台主机上运行，即一对多的方式。 例如，用Visual Basic开发的客户-服务器（C/S）模式的学生成绩管理系统的学生信息输入界面如图所示。 三层客户-服务器（B/S）模式应用系统 基于Web的数据库应用采用三层客户-服务器模式，也称为B/S结构。第一层为浏览器，第二层为Web服务器，第三层为数据库服务器。浏览器是用户输入数据和显示结果的交互界面。用户在浏览器表单中输入数据，然后将表单中的数据提交并发送到Web服务器。Web服务器应用程序接收并处理用户的数据，通过数据库服务器，从数据库中查询需要的数据（或把数据录入数据库）并返回给Web服务器。Web服务器再把返回的结果插入HTML页面，传送到客户端，在浏览器中显示出来。三层客户-服务器结构如图所示。 三层客户-服务器结构 例如，用ASP.NET开发的三层客户-服务器（B/S）模式的学生成绩管理系统的学生信息更新页面如图1.15所示。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "},"books/1999.html":{"url":"books/1999.html","title":"end1061","keywords":"","body":"end1061 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:45:08 "}}